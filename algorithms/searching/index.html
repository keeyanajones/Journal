<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>My Journal</title>   
    <!-- Latest compiled and minified CSS -->     
    <!-- Font Awesome 5.0.13 -->     
    <link rel="stylesheet" 
          href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" 
          integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" 
          crossorigin="anonymous">         
    <!-- Bootstrap 3.3.7 --> 
    <link rel="stylesheet" 
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
          crossorigin="anonymous">
    <!-- Custom Style Pygment and Icons -->     
    <link rel="stylesheet" href="../../assets/stylesheets/styles.css">
    <link rel="stylesheet" href="../../assets/stylesheets/pygment_trac.css">
    <link rel="icon" href="../../assets/images/favicon.ico" type="image/gif">
    <link rel="shortcut icon" href="../../assets/images/favicon.png">    
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  
  <body>
    <div class="wrapper">               
    <!-- Header -->         
      <header>
        <h2><span class="fa fa-book fa-5x"></span>
          <span class="fa fa-pencil-alt fa-2x"></span><br/>
            Journal </h2>
          
        <p class="view"><sup>A Journal for GitHub Pages</sup><br/>        
          <a href="https://github.com/keeyanajones/Journal">
            <span class="fab fa-github"></span> 
              View the Journal on GitHub 
              <small>keeyanajones/Journal</small></a>
        </p><br/>                                        
              
        <button class="btn btn-lg btn-block btn-default" type="button">
          JAVA <span class="fab fa-java fa-2x"></span> 
               <span class="badge"> 50+ </span>
        </button>                
        <br/>                
         <a href="https://github.com/keeyanajones/Java-Data-Structures">
            <small><span class="fab fa-github"></span>                 
              keeyanajones/Java-Data-Structures</small></a>  
         <a href="https://github.com/keeyanajones/Java-Design-Patterns">
            <small><span class="fab fa-github"></span> 
              keeyanajones/Java-Design-Patterns</small></a>                
         <a href="https://github.com/keeyanajones/Java-Problems">
            <small><span class="fab fa-github"></span> 
              keeyanajones/Java-Problems</small></a>        
          <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms">
            <small><span class="fab fa-github"></span>      
             keeyanajones/Java-Sorting-Algorithms</small></a>                
        <br/>
        <ul>    
          <li><a href="https://github.com/keeyanajones/Journal/archive/master.zip">
              <span class="fa fa-file-archive" aria-hidden="true"></span><br/>
                  Download <br/> ZIP</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-clone" aria-hidden="true"></span><br/>
                  Clone <br/> Desktop</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-code-branch" aria-hidden="true"></span><br/>
                  Fork On <br/> GitHub</a></li>
        </ul>                         
      </header>
    <!-- ./header --> 
    </div>          
      
    <section>
        <h2>Journal for 
        <span class="fab fa-git-square" aria-hidden="true"></span>Hub Pages</h2>

          <h3><span class="fa fa-project-diagram " aria-hidden="true"></span>
              <a name="searching" class="anchor" href="#searching">
              <span class="header-link"></span></a>
          Algorithms in Java : <em>Searching</em></h3>                  
     
        <p>Last updated on May 11th, 2018</p>
              
        <p>A Journal by Keeyana Jones 
         (<a href="https://twitter.com/keeyanajones">@keeyanajones</a>)</p>
                                   
        <ol class="breadcrumb">
          <li><a href="../../index.html">Home</a></li>
          <li><a href="../index.html">Algorithms</a></li>
          <li class="active"><a href="#searching">
                 Searching</a></li>
        </ol>
                                  
        <p>A search algorithm is any algorithm which solves the search problem, 
           namely, to retrieve information stored within some data structure, or
           calculated in the search space of a problem domain. Examples of such 
           structures include but are not limited to a linked list, an array 
           data structure, or a search tree. The appropriate search algorithm 
           often depends on the data structure being searched, and may also 
           include prior knowledge about the data. Searching also encompasses 
           algorithms that query the data structure, such as the SQL SELECT 
           command.</p>

        <p>Search algorithms can be classified based on their mechanism of 
           searching. Linear search algorithms check every record for the one 
           associated with a target key in a linear fashion. Binary, or half 
           interval searches, repeatedly target the center of the search 
           structure and divide the search space in half. Comparison search 
           algorithms improve on linear searching by successively eliminating 
           records based on comparisons of the keys until the target record is 
           found, and can be applied on data structures with a defined order. 
           Digital search algorithms work based on the properties of digits in 
           data structures that use numerical keys. Finally, hashing directly 
           maps keys to records based on a hash function. Searches outside a 
           linear search require that the data be sorted in some way.</p>

        <p>Search functions are also evaluated on the basis of their complexity,
           or maximum theoretical run time. Binary search functions, for 
           example, have a maximum complexity of O(log n), or logarithmic time. 
           This means that the maximum number of operations needed to find the 
           search target is a logarithmic function of the size of the search 
           space.</p>
        
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-body">
            <a name="linear" id="linear"></a>                                
            <h4>Linear Search</h4>  
            
            <p class="card-text">Linear search is a very simple search 
                algorithm. In this type of search, a sequential search is made 
                over all items one by one. Every item is checked and if a match 
                is found then that particular item is returned, otherwise the 
                search continues till the end of the data collection.</p>


Algorithm
<pre>
<code>
Linear Search ( Array A, Value x)

Step 1: Set i to 1
Step 2: if i > n then go to step 7
Step 3: if A[i] = x then go to step 6
Step 4: Set i to i + 1
Step 5: Go to Step 2
Step 6: Print Element x Found at index i 
        and go to step 8
Step 7: Print element not found
Step 8: Exit
</code>
</pre>

Pseudocode
<pre>
<code>
procedure linear_search (list, value)
   for each item in the list
      if match item == value
         return the item's location
      end if
   end for
end procedure          
</code>          
</pre>              
          </div>
        </div>

        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-body">

            <a name="binary" id="binary"></a>                                
            <h4>Binary Search</h4>  
            
            <p class="card-text">Binary search is a fast search algorithm with 
                run-time complexity of Ο(log n). This search algorithm works on 
                the principle of divide and conquer. For this algorithm to work 
                properly, the data collection should be in the sorted form.</p>

            <p>Binary search looks for a particular item by comparing the middle
               most item of the collection. If a match occurs, then the index of
               item is returned. If the middle item is greater than the item, 
               then the item is searched in the sub-array to the left of the 
               middle item. Otherwise, the item is searched for in the sub-array
               to the right of the middle item. This process continues on the 
               sub-array as well until the size of the subarray reduces to 
               zero.</p>

            <h4>How Binary Search Works?</h4>
            <p>For a binary search to work, it is mandatory for the target array
               to be sorted. We shall learn the process of binary search with a 
               pictorial example. The following is our sorted array and let us 
               assume that we need to search the location of value 31 using 
               binary search.</p>

            <p>First, we shall determine half of the array by using this 
               formula:</p>

<pre>
<code>            
mid = low + (high - low) / 2
</code>
</pre>

            <p>Here it is, 0 + (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 
                is the mid of the array.</p>

            <p>Now we compare the value stored at location 4, with the value 
               being searched, i.e. 31. We find that the value at location 4 is 
               27, which is not a match. As the value is greater than 27 and we 
               have a sorted array, so we also know that the target value must 
               be in the upper portion of the array.</p>

            <p>We change our low to mid + 1 and find the new mid value 
                again.</p>

<pre>
<code>            
low = mid + 1
mid = low + (high - low) / 2
</code>
</pre>

            <ul>
              <li>Our new mid is 7 now. We compare the value stored at location
                  7 with our target value 31.</li>
              <li>The value stored at location 7 is not a match, rather it is 
                  more than what we are looking for. So, the value must be in 
                  the lower part from this location.</li>
              <li>Hence, we calculate the mid again. This time it is 5.</li>
              <li>We compare the value stored at location 5 with our target 
                  value. We find that it is a match.</li>
              <li>We conclude that the target value 31 is stored at 
                  location 5.</li>
              <li>Binary search halves the searchable items and thus reduces 
                  the count of comparisons to be made to very less numbers.</li>
            </ul>
                
Pseudocode
            <p>The pseudocode of binary search algorithms should look like 
               this:</p>
<pre>
<code>
Procedure binary_search
   A ← sorted array
   n ← size of array
   x ← value to be searched

   Set lowerBound = 1
   Set upperBound = n 

   while x not found
      if upperBound < lowerBound 
         EXIT: x does not exists.   
      set midPoint = lowerBound + 
                    ( upperBound - lowerBound ) / 2
      if A[midPoint] < x
         set lowerBound = midPoint + 1        
      if A[midPoint] > x
         set upperBound = midPoint - 1 
      if A[midPoint] = x 
         EXIT: x found at location midPoint
   end while   
end procedure
</code>
</pre>

        <a name="interpolation" id="interpolation"></a>                  
        <h4>Interpolation Search</h4>
        
        <p>Interpolation search is an improved variant of binary search. This 
           search algorithm works on the probing position of the required value. 
           For this algorithm to work properly, the data collection should be in
           a sorted form and equally distributed.</p>

        <p>Binary search has a huge advantage of time complexity over linear 
           search. Linear search has worst-case complexity of Ο(n) whereas 
           binary search has Ο(log n).</p>

        <p>There are cases where the location of target data may be known in 
           advance. For example, in case of a telephone directory, if we want 
           to search the telephone number of Morphius. Here, linear search and 
           even binary search will seem slow as we can directly jump to memory 
           space where the names start from 'M' are stored.</p>

        <h4>Positioning in Binary Search</h4>
        <p>In binary search, if the desired data is not found then the rest of 
           the list is divided in two parts, lower and higher. The search is 
           carried out in either of them.</p>

        <p>Even when the data is sorted, binary search does not take advantage 
           to probe the position of the desired data.</p>

        <h4>Position Probing in Interpolation Search</h4>
        <p>Interpolation search finds a particular item by computing the probe 
           position. Initially, the probe position is the position of the middle
           most item of the collection.

        <p>If a match occurs, then the index of the item is returned. To split 
           the list into two parts, we use the following method:</p>

<pre>
<code>
mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo])

where:
   A    = list
   Lo   = Lowest index of the list
   Hi   = Highest index of the list
   A[n] = Value stored at index n in the list
</code>
</pre>   
   
        <p>If the middle item is greater than the item, then the probe position 
           is again calculated in the sub-array to the right of the middle item. 
           Otherwise, the item is searched in the subarray to the left of the 
           middle item. This process continues on the sub-array as well until 
           the size of subarray reduces to zero.</p>

        <p>Runtime complexity of interpolation search algorithm is 
           Ο(log (log n)) as compared to Ο(log n) of BST in favorable 
           situations.</p>

        <h4>Algorithm</h4>
        <p>As it is an improvisation of the existing BST algorithm, we are 
           mentioning the steps to search the 'target' data value index, using 
           position probing</p>

<pre>
<code>
Step 1 − Start searching data from middle of the list.
Step 2 − If it is a match, return the index of the 
         item, and exit.
Step 3 − If it is not a match, probe position.
Step 4 − Divide the list using probing formula and find 
         the new middle.
Step 5 − If data is greater than middle, search in higher 
         sub-list.
Step 6 − If data is smaller than middle, search in lower 
         sub-list.
Step 7 − Repeat until match.
</code>
</pre>

Pseudocode
<pre>
<code>
A → Array list
N → Size of A
X → Target Value

Procedure Interpolation_Search()

   Set Lo  →  0
   Set Mid → -1
   Set Hi  →  N-1

   While X does not match
   
      if Lo equals to Hi OR A[Lo] equals to A[Hi]
         EXIT: Failure, Target not found
      end if
      
      Set Mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo]) 

      if A[Mid] = X
         EXIT: Success, Target found at Mid
      else 
         if A[Mid] < X
            Set Lo to Mid+1
         else if A[Mid] > X
            Set Hi to Mid-1
         end if
      end if
 
   End While
End Procedure
</code>
</pre>

        <a name="hash" id="hash"></a>                  
        <h4>Hash Tables</h4>

        <p>Hash Table is a data structure which stores data in an associative 
           manner. In a hash table, data is stored in an array format, where 
           each data value has its own unique index value. Access of data 
           becomes very fast if we know the index of the desired data.</p>
            
        <p>Thus, it becomes a data structure in which insertion and search 
           operations are very fast irrespective of the size of the data. Hash 
           Table uses an array as a storage medium and uses hash technique to 
           generate an index where an element is to be inserted or is to be 
           located from.</p>

        <h5>Hashing</h5>
        <p>Hashing is a technique to convert a range of key values into a range 
           of indexes of an array. We're going to use modulo operator to get a 
           range of key values. Consider an example of hash table of size 20, 
           and the following items are to be stored. Item are in the 
           (key,value) format.</p>

<pre>
<code>        
Hash Function
(1,20)
(2,70)
(42,80)
(4,25)
(12,44)
(14,32)
(17,11)
(13,78)
(37,98)

Sr. No.	Key	Hash         Array Index
1	1	1 % 20 = 1	1
2	2	2 % 20 = 2	2
3	42	42 % 20 = 2	2
4	4	4 % 20 = 4	4
5	12	12 % 20 = 12	12
6	14	14 % 20 = 14	14
7	17	17 % 20 = 17	17
8	13	13 % 20 = 13	13
9	37	37 % 20 = 17	17
</code>
</pre>

        <h4>Linear Probing</h4>
        <p>As we can see, it may happen that the hashing technique is used to 
           create an already used index of the array. In such a case, we can 
           search the next empty location in the array by looking into the next 
           cell until we find an empty cell. This technique is called linear 
           probing.</p>

<pre>
<code>
Sr. No.	Key	Hash         Array Index   After Linear 
                                           Probing, 
                                           Array Index
1	1	1 % 20 = 1	1           1
2	2	2 % 20 = 2	2           2
3	42	42 % 20 = 2	2           3
4	4	4 % 20 = 4	4           4
5	12	12 % 20 = 12	12          12
6	14	14 % 20 = 14	14          14
7	17	17 % 20 = 17	17          17
8	13	13 % 20 = 13	13          13
9	37	37 % 20 = 17	17          18
</code>
</pre>

        <h4>Basic Operations</h4>
        <p>Following are the basic primary operations of a hash table.</p>

        <ul>
          <li>Search − Searches an element in a hash table.</li>
          <li>Insert − inserts an element in a hash table.</li>
          <li>Delete − Deletes an element from a hash table.</li>
        </ul>
        
        <h4>DataItem</h4>
        <p>Define a data item having some data and key, based on which the 
           search is to be conducted in a hash table.</p>

<pre>
<code>        
struct DataItem {
   int data;   
   int key;
};
</code>
</pre>
        
        <h4>Hash Method</h4>
        <p>Define a hashing method to compute the hash code of the key of the 
           data item.</p>

<pre>
<code>        
int hashCode(int key){
   return key % SIZE;
}
</code>
</pre>
        
        <h4>Search Operation</h4>
        <p>Whenever an element is to be searched, compute the hash code of the 
           key passed and locate the element using that hash code as index in 
           the array. Use linear probing to get the element ahead if the element
           is not found at the computed hash code.</p>

Example
<pre>
<code>
struct DataItem *search(int key) {
   //get the hash 
   int hashIndex = hashCode(key);
	
   //move in array until an empty 
   while(hashArray[hashIndex] != NULL) {
	
      if(hashArray[hashIndex]->key == key)
         return hashArray[hashIndex];
			
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }
	
   return NULL;        
}
</code>
</pre>

        <h4>Insert Operation</h4>
        <p>Whenever an element is to be inserted, compute the hash code of the 
           key passed and locate the index using that hash code as an index in 
           the array. Use linear probing for empty location, if an element is 
           found at the computed hash code.</p>

Example
<pre>
<code>
void insert(int key,int data) {
   struct DataItem *item = (struct DataItem*) 
                           malloc(sizeof(struct DataItem));
   item->data = data;  
   item->key = key;     

   //get the hash 
   int hashIndex = hashCode(key);

   //move in array until an empty or deleted cell
   while(hashArray[hashIndex] != NULL && 
         hashArray[hashIndex]->key != -1) {
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }
	
   hashArray[hashIndex] = item;        
}
</code>
</pre>

        <h4>Delete Operation</h4>
        <p>Whenever an element is to be deleted, compute the hash code of the 
           key passed and locate the index using that hash code as an index in 
           the array. Use linear probing to get the element ahead if an element 
           is not found at the computed hash code. When found, store a dummy 
           item there to keep the performance of the hash table intact.</p>

Example
<pre>
<code>
struct DataItem* delete(struct DataItem* item) {
   int key = item->key;

   //get the hash 
   int hashIndex = hashCode(key);

   //move in array until an empty 
   while(hashArray[hashIndex] !=NULL) {
	
      if(hashArray[hashIndex]->key == key) {
         struct DataItem* temp = hashArray[hashIndex]; 
			
         //assign a dummy item at deleted position
         hashArray[hashIndex] = dummyItem; 
         return temp;
      } 
		
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }  
	
   return NULL;        
}
</code>
</pre>
          </div>
        </div>
                             
<hr/>

        <h3><a name="take-five" class="anchor" href="#take-five">
          <span class="header-link"></span></a>
          Review</h3>
          
        <p>Alright, let's recap what I've just learned:</p>
    
        <ul>
            <li>Searching is a procedure of any algorithm which solves the 
                search problem, namely, to retrieve information stored within 
                some data structure, or calculated in the search space of a 
                problem domain.</li>          
        </ul>
        
    <p>You can read more at: 
        <a href="https://go.java/">
           https://go.java</a></p>

      <!-- pagination -->
       <a role="button" class="btn btn-primary pull-left"  
               href="../index.html">
            &larr; PREVIOUS: Algorithms</a>
          
      <a role="button" class="btn btn-primary pull-right" 
              href="../../uml/index.html">
            NEXT: Unified Modeling Language (UML) &rarr;</a><br/><br/>

        <hr/>                        
        
        <a name="copyright" id="copyright"></a>
        <p><sup><span class="fa fa-copyright" aria-hidden="true"></span> 
            <strong>Copyright and license</strong><br/>
                Code and documentation copyright 2018 Keeyana Jones. Code released 
            under the MIT license. Docs released under Creative Commons.
        </sup></p>           
        
         <a href="#top">
             <span class="fa fa-arrow-up" aria-hidden="true">                 
             </span></a>         

                   
    </section>
        
    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" 
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" 
            crossorigin="anonymous"></script>         
    <script src="../../javascripts/scale.fix.js"></script>
  </body>
</html>

            