<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Code Journal: Sorting Algorithms</title>   
    <!-- Latest compiled and minified CSS -->     
    <!-- Font Awesome 5.0.13 -->     
    <link rel="stylesheet" 
          href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" 
          integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" 
          crossorigin="anonymous">         
    <!-- Bootstrap 3.3.7 --> 
    <link rel="stylesheet" 
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
          crossorigin="anonymous">
    <!-- Highlight.js 9.13.1 -->     
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/androidstudio.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>    
    <script>hljs.initHighlightingOnLoad();</script>  
    
    <!-- Custom Style Pygment and Icons -->     
    <link rel="stylesheet" href="../../assets/stylesheets/styles.css">
    <link rel="stylesheet" href="../../assets/stylesheets/pygment_trac.css">
    <link rel="icon" href="../../assets/images/favicon.ico" type="image/gif">
    <link rel="shortcut icon" href="../../assets/images/favicon.png">    
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  
  <body>
    <div class="wrapper">               
    <!-- Header -->         
      <header>
          <img src="../../assets/images/pb_Image.png" class="img-fluid" alt="me"/>
        <p class="view">A Code Journal for 
            <span class="fab fa-git-square" aria-hidden="true"></span>
                Hub Pages<br/>        
                
            <a href="https://github.com/keeyanajones/Journal" target="_blank">
            <span class="fab fa-github"></span> 
              View the Code Journal on GitHub</a></p>
                      
                        
            <button class="btn btn-md btn-default" type="button">
                <span class="fab fa-java fa-2x"></span> 
            </button>                
            
            <button class="btn btn-md btn-default" type="button">
                <span class="fab fa-python fa-2x"></span> 
            </button>                        

            <button class="btn btn-md btn-default" type="button">
                <span class="fab fa-r-project  fa-2x"></span> 
            </button>                
            
            <button class="btn btn-md btn-default" type="button">
            <span class="fab fa-js fa-2x"></span> 
            </button>                              

            <br/><br/>
            
            <a href="https://github.com/keeyanajones/">
            <small><span class="fab fa-github-alt"></span>                 
            Repositories and latest Contribution Activity</small></a>                 
              
        <br/>
        
        <!-- Download, Clone, or Fork -->
        <ul>    
          <li><a href="https://github.com/keeyanajones/Journal/archive/master.zip">
              <span class="fa fa-file-archive" aria-hidden="true"></span><br/>
                  Download <br/> ZIP</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-clone" aria-hidden="true"></span><br/>
                  Clone <br/> Desktop</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-code-branch" aria-hidden="true"></span><br/>
                  Fork On <br/> GitHub</a></li>
        </ul>                                 
      </header>
    <!-- ./header --> 
    </div>          
      
    <section>        
        <h2><span class="fa fa-project-diagram " aria-hidden="true"></span>
              <a name="sorting" class="anchor" href="#sorting">
              <span class="header-link"></span></a>
          Algorithms <sup>in Java : <em>Sorting</em></sup></h2>                  
     
        <p><sup><span class="fa fa-calendar"></span>
                Last updated on January 1st, 2019<sup></p>
                                         
        <ol class="breadcrumb">
          <li><span class="fa fa-bookmark"></span> <a href="../../index.html">Home</a></li>
          <li><a href="../index.html"><span class="fa fa-bookmark"></span> Algorithms</a></li>
          <li class="active"><a href="#sorting">
              <span class="fa fa-bookmark"></span> Sorting</a></li>
        </ol>
                            
        <p>There are numerous types of sorting, generally that puts elements of 
            a list in a certain order. The most-used orders are numerical order 
            and lexicographical order.</p>

        <p> Efficient sorting is important for optimizing the use of others 
            (such as search and merge) which require input data to 
            be in sorted lists; it is also often useful for canonicalizing 
            data and for producing human-readable output. More formally, 
            the output must satisfy two conditions:</p>
            
        <ul>
          <li>The output is in nondecreasing order (each element is no smaller 
              than the previous element according to the desired total 
              order)</li>
          <li>The output is a permutation (reordering but with all of the 
              original elements) of the input.</li>
        </ul>
        
        <p>Further, the data is often taken to be in an array, which allows 
           random access, rather than a list, which only allows sequential 
           access, though often can be applied with suitable modification to 
           either type of data.</p>

        <h3>In-place Sorting and Not-in-place Sorting</h3>
        <p>Sorting algorithms may require some extra space for comparison and 
           temporary storage of few data elements. These algorithms do not 
           require any extra space and sorting is said to happen in-place, or 
           for example, within the array itself. This is called in-place 
           sorting. Bubble sort is an example of in-place sorting.</p>

        <p>However, in some sorting algorithms, the program requires space 
           which is more than or equal to the elements being sorted. Sorting 
           which uses equal or more space is called not-in-place sorting. 
           Merge-sort is an example of not-in-place sorting.</p>

        <h4>Stable and Not Stable Sorting</h4>        
        <ul>
          <li>If a sorting algorithm, after sorting the contents, does not 
              change the sequence of similar content in which they appear, it 
              is called stable sorting.</li>
          <li>If a sorting algorithm, after sorting the contents, changes the 
              sequence of similar content in which they appear, it is called 
              unstable sorting.</li>
        </ul>
        
        <p>Stability of an algorithm matters when we wish to maintain the 
           sequence of original elements, like in a tuple for example.</p>

        <h4>Adaptive and Non-Adaptive Sorting Algorithm</h4>
        <ul>
          <li>A sorting algorithm is said to be adaptive, if it takes advantage 
              of already 'sorted' elements in the list that is to be sorted. 
              That is, while sorting if the source list has some element already
              sorted, adaptive algorithms will take this into account and will 
              try not to re-order them.</li>
          <li>A non-adaptive algorithm is one which does not take into account 
              the elements which are already sorted. They try to force every 
              single element to be re-ordered to confirm their sortedness.</li>
        </ul>
        
        <h4>Important Terms</h4>
        <p>Some terms are generally coined while discussing sorting techniques, 
           here is a brief introduction to them:</p>

        <ul>
          <li>Increasing Order - A sequence of values is said to be in 
                                 increasing order, if the successive element is 
                                 greater than the previous one. For example, 1, 
                                 3, 4, 6, 8, 9 are in increasing order, as every
                                 next element is greater than the previous 
                                 element.</li>
          <li>Decreasing Order - A sequence of values is said to be in 
                                 decreasing order, if the successive element is 
                                 less than the current one. For example, 9, 8, 
                                 6, 4, 3, 1 are in decreasing order, as every 
                                 next element is less than the previous 
                                 element.</li>
          <li>Non-Increasing Order - A sequence of values is said to be in 
                                     non-increasing order, if the successive 
                                     element is less than or equal to its 
                                     previous element in the sequence. This 
                                     order occurs when the sequence contains 
                                     duplicate values. For example, 9, 8, 6, 3, 
                                     3, 1 are in non-increasing order, as every 
                                     next element is less than or equal to 
                                     (in case of 3) but not greater than any 
                                     previous element.</li>
          <li>Non-Decreasing Order - A sequence of values is said to be in 
                                     non-decreasing order, if the successive 
                                     element is greater than or equal to its 
                                     previous element in the sequence. This 
                                     order occurs when the sequence contains 
                                     duplicate values. For example, 1, 3, 3, 6, 
                                     8, 9 are in non-decreasing order, as every 
                                     next element is greater than or equal to 
                                     (in case of 3) but not less than the 
                                     previous one.</li>
        </ul>


        
        <a name="common" id="common"></a>                               
        <h4>A.) Common Sorts </h4>
        <p>There are many different sorting algorithms, with various pros and 
            cons. All sorting problem that can be sorted with non-comparison 
            sort algorithm can be sorted with comparison sort algorithm, but 
            <em><strong>NOT</strong></em> vice versa. Here are a few examples 
            of common sorting algorithms.</p>               
       
        <p><sup>See <a href="../../big-o-notations/index.html">
            Big O' Notations</a> for more...</sup></p>
            
        <!-- Large modal -->
        <!-- Trigger the modal with a button -->
        <button type="button" class="btn btn-primary" data-toggle="modal" 
                data-target="#myModal1">See Common Sort Table 
            <span class="fa fa-window-restore"></span>
        </button>
        <!-- /.Trigger -->    
        <br/><br/>

        <!-- Common Sorts Modal -->
        <div id="myModal1" class="modal fade" role="dialog">
          <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <button type="button" class="close" 
                        data-dismiss="modal" aria-label="Close">
                    <span class="fa fa-window-close" 
                          aria-hidden="true"></span>
                </button>
                <h4 class="modal-title">Common Sorts</h4>
              </div>
                
              <div class="modal-body">
              <table class="table table-striped table-responsive">
                <!-- Table Headers -->  
                <tr>
                  <th>Name</th>
                  <th>Best&nbsp;&nbsp;&nbsp;</th>
                  <th>Average&nbsp;&nbsp;</th>
                  <th>Worst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Memory</th>
                  <th>Stable</th>
                  <th>Method</th>
                  <th>Notes</th>
                </tr>        

                <tr>
                  <td>Merge</td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n</em> a hybrid block merge sort is 0(1) mem.</td>
                  <td>Yes</td>
                  <td>Merging</td>
                  <td>Highly parallelizable (up to O(log n) using the Three 
                      Hungarians' Algorithm or, more practically, Cole's parallel merge
                      sort) for processing large amounts of data</td>
                </tr>  

                <tr>
                  <td>Insertion</td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td>Insertion</td>
                  <td>O(n + d), in the worst case over sequences that have d inversions</td>
                </tr>  

                <tr>
                  <td>Bubble</td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td>Exchanging</td>
                  <td>Tiny Code Size</td>
                </tr>  

                <tr>
                  <td>Quick</td>
                  <td><em>n log n</em> variation is <em>n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>log n</em> on average, worst is 
                      <em>n</em>; Sedgewick variation is <em>log n</em>
                      worst</td>
                  <td>Typical in-place sort is not stable; stable versions exist</td>
                  <td>Partitioning</td>
                  <td>Quicksort is usually done in-place with O(log n) stack space</td>
                </tr>  

                <tr>
                  <td>Heap</td>
                  <td><em>O(n)</em> variation is <em>n</em></td>
                  <td><em>O(n log n)</em></td>
                  <td><em>O(n log n)</em></td>
                  <td><em>O(1)</em> auxiliary</td>
                  <td>No</td>
                  <td>First elements are reordered to satisfy the heap property. 
                      Before the actual sorting takes place</td>
                  <td>Improved selection sort, it divides its input into a sorted and 
                      an unsorted region, and it iteratively shrinks the unsorted 
                      region by extracting the largest element and moving that to the 
                      sorted region. The improvement consists of the use of a heap data 
                      structure rather than a linear-time search to find the maximum.
                      Slower in practice on most machines than a well-implemented 
                      quicksort, it has the advantage of a more favorable worst-case 
                      O(n log n) runtime</td>
                </tr>  

                <tr>
                  <td>Counting</td>
                  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                  <td><em>n + r</em></td>
                  <td><em>n + r</em></td>
                  <td><em>n + r</em></td>
                  <td>Yes</td>
                  <td><em>n &Lt; 2<sup>k</sup></em></td>
                  <td>If r is O(n), then average time complexity is O(n)</td>
                </tr>  

                <tr>
                  <td>Selection</td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>No</td>
                  <td>Selection</td>
                  <td>Stable with O(n) extra space, for example using lists</td>
                </tr>  
                </table>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
              </div>
            </div>
            <!-- /.modal-content -->
          </div>
          <!-- /.modal-dialog -->
        </div>
        <!-- /.modal --> 
        <!-- End Large modal -->
        
        <a name="merge" id="merge"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Merge Sort</strong></div>
          <div class="card-body">
            <p class="card-text">Merge sort takes advantage of the ease of 
                merging already sorted lists into a new sorted list. It starts 
                by comparing every two elements (i.e., 1 with 2, then 3 with 
                4...) and swapping them if the first should come after the 
                second. It then merges each of the resulting lists of two into 
                lists of four, then merges those lists of four, and so on; 
                until at last two lists are merged into the final sorted 
                list.</p>
  
            <p>Of the algorithms described here, this is the first that scales 
               well to very large lists, because its worst-case running time is 
               O(n log n). It is also easily applied to lists, not only arrays, 
               as it only requires sequential access, not random access. 
               However, it has additional O(n) space complexity, and involves a 
               large number of copies in simple implementations.</p>   
            
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/MergeSort.java"
       target="_blank"> 
       MergeSort.java</a>    
          
<pre>
<code class="java">  
public class MergeSort {   
 private int[] array;
 private int[] tempMergArr;
 private int length; 

 public static void main(String[] args) {
  // create an int array we want to sort 
  // using merge sort algorithm
  int intArray[] = new 
      int[] {45,23,11,89,77,98,4,28,65,43};

  // print array before sorting 
  // using merge sort algorithm
  System.out.println("Array Before Merge Sort");
  for(int i:intArray){
   System.out.print(i + " ");
  }           
  MergeSort ms = new MergeSort();
  ms.sort(intArray);
 }

 public void sort(int intArray[]) {
  this.array = intArray;
  this.length = intArray.length;
  this.tempMergArr = new int[length];
  // sort an array using merge sort algorithm
  mergeSort(0, length - 1);
  // print array after sorting 
  // using merge sort algorithm
  System.out.println(" ");
  System.out.println("Array After Merge Sort");
  for (int i = 0; i < intArray.length; i++) {
   System.out.print(intArray[i] + " ");
  } 
 }

 private void mergeSort(int lowerIndex, 
                        int higherIndex) {         
  if (lowerIndex < higherIndex) {
   int middle = lowerIndex + 
                (higherIndex - lowerIndex) / 2;
   // Below step sorts the left side of the array
   mergeSort(lowerIndex, middle);
   // Below step sorts the right side of the array
   mergeSort(middle + 1, higherIndex);
   // Now merge both sides
   mergeParts(lowerIndex, middle, higherIndex);
  }
 }

 private void mergeParts(int lowerIndex, 
                         int middle, 
                         int higherIndex) { 
  for (int i = lowerIndex; i <= higherIndex; i++) {
    tempMergArr[i] = array[i];
  }

  int i = lowerIndex;
  int j = middle + 1;
  int k = lowerIndex;

  while (i <= middle && j <= higherIndex) {
   if (tempMergArr[i] <= tempMergArr[j]) {
       array[k] = tempMergArr[i];
       i++;
   } else {
       array[k] = tempMergArr[j];
       j++;
   }
    k++;
  }

  while (i <= middle) {
   array[k] = tempMergArr[i];
   k++;
   i++;
  } 
 }
}
</code>    
</pre>
            
          </div>
        </div>

        <a name="insertion" id="insertion"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Insertion Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A simple sorting algorithm that is relatively 
                efficient for small lists and mostly sorted lists, and is often 
                used as part of more sophisticated algorithms. It works by 
                taking elements from the list one by one and inserting them in 
                their correct position into a new sorted list. In arrays, the 
                new list and the remaining elements can share the array's space,
                but insertion is expensive, requiring shifting all following 
                elements over by one. </p>
            
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/InsertionSort.java"
       target="_blank"> 
       InsertionSort.java</a>                
            
<pre>
<code class="java">
public class InsertionSort { 
 public static void main(String[] args) {                 
  // create an int array we want to sort 
  // using insertion sort
  int intArray[] = new int[] {10,34,2,56,7,67,88,42};

  // print array before sorting using insertion sort
  System.out.println("Array Before Insertion Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
  }               

  // sort an array using insertion sort
  insertionSort(intArray);

  System.out.println("");

  // print array after sorting using insertion sort
  System.out.println("Array After Insertion Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
  } 
 }

 private static void insertionSort(int[] intArray) {
  int n = intArray.length;
  int temp = 0;

  for (int i = 1; i < n; i++) {
   for (int j = i; j > 0; j--) {                
    if (intArray[j] < intArray[j - 1]) {
     //swap the elements!
     temp = intArray[j];
     intArray[j] = intArray[j - 1];
     intArray[j - 1] = temp;
    }
   }
  }
 }
}    
</code>    
</pre>

          </div>
        </div>
            
        <a name="bubble" id="bubble"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Bubble Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A simple sorting algorithm that repeatedly 
                steps through the list to be sorted, compares each pair of 
                adjacent items and swaps them if they are in the wrong order. 
                The pass through the list is repeated until no swaps are needed,
                which indicates that the list is sorted. The algorithm, which 
                is a comparison sort, is named for the way smaller or larger 
                elements "bubble" to the top of the list.</p> 
            
            <p>Although the algorithm is simple, it is too slow and impractical 
               for most problems even when compared to insertion sort. It can 
               be practical if the input is usually in sorted order but may 
               occasionally have some out-of-order elements nearly in position.
            </p>
            
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/BubbleSort.java"
       target="_blank"> 
       BubbleSort.java</a>    
                      
<pre>
<code class="java">
public class BubbleSort { 
 public static void main(String[] args) {
  // create an int array we want to 
  // sort using bubble sort
  int intArray[] = new int[] {5,90,35,45,150,3};

  // print array before sorting using bubble sort 
  System.out.println("Array Before Bubble Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
  }
  // sort an array using bubble sort algorithm
  bubbleSort(intArray);

  System.out.println("");

  // print array after sorting using bubble sort 
  System.out.println("Array After Bubble Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
  } 
 }

 private static void bubbleSort(int[] intArray) {
  int n = intArray.length;
  int temp = 0;

  for (int i = 0; i < n; i++) {
   for (int j = 1; j < (n - i); j++) {
    if (intArray[j - 1] > intArray[j]) {
        //swap the elements!
        temp = intArray[j - 1];
        intArray[j - 1] = intArray[j];
        intArray[j] = temp;
    }
   }
  }
 }
}
</code>    
</pre>
            
          </div>
        </div>       
                  
        <a name="quick" id="quick"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Quick Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A divide and conquer algorithm which relies on 
                a partition operation: to partition an array an element called 
                a pivot is selected. All elements smaller than the pivot are 
                moved before it and all greater elements are moved after it. 
                This can be done efficiently in linear time and in-place. The 
                lesser and greater sublists are then recursively sorted. This 
                yields average time complexity of O(n log n), with low overhead,
                and thus this is a popular algorithm.</p>
            
            <p>Efficient implementations of quick sort (with in-place 
               partitioning) are typically unstable sorts and somewhat complex, 
               but are among the fastest sorting algorithms in practice. 
               Together with its modest O(log n) space usage, quick sort is one 
               of the most popular sorting algorithms and is available in many 
               standard programming libraries.</p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/QuickSort.java"
       target="_blank"> 
       QuickSort.java</a>                
            
<pre>
<code class="java">
public class QuickSort {        
 private int array[];
 private int length;

 public void sort(int[] inputArray) {
  if (inputArray == null || inputArray.length == 0) {
    return;
  }        
  this.array = inputArray;
  length = inputArray.length;
  quickSort(0, length - 1);
 }

 private void quickSort(int lowerIndex, 
                        int higherIndex) {
  int i = lowerIndex;
  int j = higherIndex;

  // calculate pivot number, taking pivot
  // as middle index number
  int pivot = array[lowerIndex + 
             (higherIndex - lowerIndex) / 2];
  // Divide into two arrays
  while (i <= j) {
    /**
     * In each iteration, we will identify a number 
     * from left side which is greater then the pivot 
     * value, and also we will identify a number from 
     * right side which is less then the pivot value. 
     * Once the search is done, then we exchange both 
     * numbers.
     **/
    while (array[i] < pivot) {
        i++;
    }
    while (array[j] > pivot) {
        j--;
    }
    if (i <= j) {
        swap(i, j);
        //move index to next position on both sides
        i++;
        j--;
    }
  }
  // call quickSort() method recursively
  if (lowerIndex < j)
    quickSort(lowerIndex, j);
  if (i < higherIndex)
    quickSort(i, higherIndex);
 }         

 private void swap(int i, int j) {
  int temp = array[i];
  array[i] = array[j];
  array[j] = temp;
 }

 public static void main(String[] args) {
  QuickSort sorter = new QuickSort();
  // create an int array we want to 
  // sort using quick sort
  int[] intArray = {24,2,45,20,56,75,2,56,99,53,12};

  // print array before sorting using quick sort 
  System.out.println("Array Before Quick Sort");
  for (int i = 0; i < intArray.length; i++) {
   System.out.print(intArray[i] + " ");
  }                     
  sorter.sort(intArray);
  System.out.println(" ");

  // print array after sorting using quick sort
  System.out.println("Array After Quick Sort");
  for(int i:intArray){
   System.out.print(i);
   System.out.print(" ");
  }
 }
}      
</code>    
</pre>

          </div>
        </div>        
        
        <a name="heap" id="heap"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Heap Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A much more efficient version of selection 
                sort. It also works by determining the largest (or smallest) 
                element of the list, placing that at the end (or beginning) of 
                the list, then continuing with the rest of the list, but 
                accomplishes this task efficiently by using a data structure 
                called a heap, a special type of binary tree. Once the data list
                has been made into a heap, the root node is guaranteed to be the
                largest (or smallest) element. </p>
            
            <p>When it is removed and placed at the end of the list, the heap is
               rearranged so the largest element remaining moves to the root. 
               Using the heap, finding the next largest element takes O(log n) 
               time, instead of O(n) for a linear scan as in simple selection 
               sort. This allows Heap sort to run in O(n log n) time, and this 
               is also the worst case complexity. </p>
            
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/HeapSort.java"
       target="_blank"> 
       HeapSort.java</a>                
            
<pre>
<code class="java">
import java.util.*;

public class HeapSort {
 private static int [] a;
 private static int n;
 private static int left;
 private static int right;
 private static int largest;

 public static void heapify(int []a) {
    n = a.length - 1;
    for (int i = n / 2; i >= 0; i--) {
        siftDown(a, i);
    }
 }

 public static void siftDown(int[] a, int i) { 
  left = 2 * i;
  right = 2 * i + 1;

  if (left <= n && a[left] > a[i]) {
    largest = left;
  } else {
    largest = i;
  }

  if(right <= n && a[right] > a[largest]) {
    largest = right;
  }
  
  if(largest != i) {
    swap(i, largest);
    siftDown(a, largest);
  }
 }    

 public static void swap(int i, int j) {
   int t = a[i];
   a[i] = a[j];
   a[j] = t; 
 }

 public static void heapSort(int[] temp) {
  a = temp;
  heapify(a);
  for (int i = n; i > 0; i--) {
    swap(0, i);
    n = n - 1;
    siftDown(a, 0);
  }
 }

 public static void main(String[] args) {
  int intArray [] = new int[] 
                   {55,2,93,1,23,10,66,12,7,54,3};

  // print array before sorting using Heap sort algorithm
  System.out.println("Array Before Heap Sort");      
  System.out.println(Arrays.toString(intArray));

  heapSort(intArray);

  // print array after sorting using Heap sort algorithm
  System.out.println("Array After Heap Sort");            
  System.out.println(Arrays.toString(intArray));
 }
}      
</code>    
</pre>
            
          </div>
        </div>        
        
        <a name="counting" id="counting"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Counting Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> Applicable when each input is known to belong 
                to a particular set, S, of possibilities. The algorithm runs in 
                O(|S| + n) time and O(|S|) memory where n is the length of the 
                input. It works by creating an integer array of size |S| and 
                using the ith bin to count the occurrences of the ith member of 
                S in the input. Each input is then counted by incrementing the 
                value of its corresponding bin. Afterward, the counting array is
                looped through to arrange all of the inputs in order. </p>
            
            <p>This sorting algorithm often cannot be used because S needs to 
               be reasonably small for the algorithm to be efficient, but it is 
               extremely fast and demonstrates great asymptotic behavior as n 
               increases. It also can be modified to provide stable 
               behavior.</p>
            
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/CountingSort.java"
       target="_blank"> 
       CountingSort.java</a>                
            
<pre>
<code class="java">
import java.util.*;

public class CountingSort {
 public static void main(String[] args) { 
  // create an int array we want to 
  // sort using counting sort 
  int intArray[] = new int[] 
                   {8,4,1,56,3,44,23,6,28,0};

  // print array before sorting 
  // using counting sort 
  System.out.println("Array Before Counting Sort");
  System.out.println(Arrays.toString(intArray)); 

  // sort an array using counting sort 
  CountingSort ob = new CountingSort();
  ob.countingSort(intArray);

  System.out.println("");

  // print array after sorting using counting sort 
  System.out.println("Array After Counting Sort");
  System.out.println(Arrays.toString(intArray));
 }    

 private void countingSort(int intArray []) {
  int n = intArray.length; 

  // The output ints array that will 
  // have sorted intArray
  int output[] = new int[n];
  /**
   * Create a count array to store count of 
   * individual ints and  initialize count 
   * array as 0
   **/
  int count[] = new int[256];
  for (int i = 0; i < 256; ++i)
      count[i] = 0; 
  // store count of each int
  for (int i = 0; i < n; ++i)
      ++count[intArray[i]];
  /**
   * Change count[i] so that count[i] now 
   * contains actual position of 
   * this ints in output array
   **/ 
  for (int i = 1; i <= 255; ++i)
      count[i] += count[i - 1]; 
  // Build the output character array
  for (int i = 0; i < n; ++i) {
      output[count[intArray[i]] - 1] = intArray[i];
      --count[intArray[i]];
  } 
  // Copy the output array to intArray, 
  // so that it contains sorted list
  for (int i = 0; i < n; ++i)
      intArray[i] = output[i];
 }
}      
</code>    
</pre>

          </div>
        </div>        
        
        <a name="selection" id="selection"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Selection Sort</strong></div>
          <div class="card-body">
            <p class="card-text">An in-place comparison sort. It has O(n2) 
                complexity, making it inefficient on large lists, and generally 
                performs worse than the similar insertion sort. Selection sort 
                is noted for its simplicity, and also has performance advantages
                over more complicated algorithms in certain situations.</p> 
            
            <p>The algorithm finds the minimum value, swaps it with the value in
               the first position, and repeats these steps for the remainder of 
               the list. It does no more than n swaps, and thus is useful where 
               swapping is very expensive.</p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/common/SelectionSort.java"
       target="_blank"> 
       SelectionSort.java</a>    
            
<pre>
<code class="java">
public class SelectionSort {

 public static void main(String[] args) {
  // create an int array we want to 
  // sort using selection sort 
  int intArray[] = new int[] {9,14,3,2,43,11,58,22};

  // print array before sorting 
  // using selection sort 
  System.out.println("Array Before Selection Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
 }

 // sort an array using selection sort
 selectionSort(intArray);

 System.out.println("");

 // print array after sorting using selection sort
 System.out.println("Array After Selection Sort");
 for (int i = 0; i < intArray.length; i++) {
   System.out.print(intArray[i] + " ");
  } 
 }

 private static void selectionSort(int[] intArray) {
  int n = intArray.length;

  for (int i = 0; i < n - 1; i++) {
   int index = i;
   for (int j = i + 1; j < n; j++) {
     if (intArray[j] < intArray[index]) {
        index = j;
        int smallerNumber = intArray[index]; 
        intArray[index] = intArray[i];
        intArray[i] = smallerNumber;
    }
   }
  }
 }
}
</code>    
</pre>

          </div>
        </div>        
        
        <hr/>               
      
        <a name="comparison" id="comparison"></a>                               
        <h4>B.) Comparison Sorts </h4>
        <p>A comparison sort algorithm sorts items by comparing values between 
           each other. It can be applied to any sorting cases. And the best 
           complexity is <em>O(n*log(n))</em> 
           which can be proved mathematically.</p>  

        <p><sup>See <a href="../../big-o-notations/index.html">
            Big O' Notations</a> for more...</sup></p>
              
        <!-- Large modal -->
        <!-- Trigger the modal with a button -->
        <button type="button" class="btn btn-primary" data-toggle="modal" 
                data-target="#myModal2">See Comparison Sort Table 
            <span class="fa fa-window-restore"></span>
        </button>
        
        <br/><br/>

        <!-- Comparison Sort Modal -->
        <div id="myModal2" class="modal fade" role="dialog">
          <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <button type="button" class="close" 
                        data-dismiss="modal" aria-label="Close">
                    <span class="fa fa-window-close" aria-hidden="true"></span></button>
                <h4 class="modal-title">Comparison Sorts</h4>
              </div>
              <div class="modal-body">

              <table class="table table-striped table-responsive">
                <!-- Table Headers -->  
                <tr>
                  <th>Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Best&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Average&nbsp;&nbsp;</th>
                  <th>Worst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Memory</th>
                  <th>Stable</th>
                  <th>Method</th>
                  <th>Notes</th>
                </tr>

                <tr>
                  <td>Tree</td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em> (balanced)</td>
                  <td><em>n</em></td>
                  <td>yes</td>
                  <td>Insertion</td>
                  <td>When using a self-balancing binary search tree</td>
                </tr>

                <tr>
                  <td>Block</td>
                  <td><em>n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td>Insertion &amp; Merging</td>
                  <td>Combine a block-based O(n) in-place merge algorithm with a 
                      bottom-up merge sort</td>
                </tr>        

                <tr>
                  <td>Cocktail</td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td>Exchanging</td>
                  <td> </td>
                </tr>        

                <tr>
                  <td>Comb</td>
                  <td><em>n log n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>No</td>
                  <td>Exchanging</td>
                  <td>Faster than bubble sort on average</td>
                </tr>

                <tr>
                  <td>Cube</td>
                  <td><em>n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n</em></td>
                  <td>Yes</td>
                  <td>Insertion</td>
                  <td>Makes <em>n</em> comparisons when the data is already sorted 
                      or reverse sorted</td>
                </tr>

                <tr>
                  <td>Cycle</td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>No</td>
                  <td>Insertion</td>
                  <td>In-place with theoretically optimal number of writes</td>
                </tr>

                <tr>
                  <td>Fanceschinis</td>
                  <td> </td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td> </td>
                  <td> </td>
                </tr>

                <tr>
                  <td>Gnome</td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td>Exchanging</td>
                  <td>Tiny code size</td>
                </tr> 

                <tr>
                  <td>Intro</td>
                  <td><em>n log n</em> </td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>log n</em></td>
                  <td>No</td>
                  <td>Partitioning &amp; Selection </td>
                  <td>Used in several STL implementations</td>
                </tr>

                <tr>
                  <td>Library</td>
                  <td><em>n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n</em></td>
                  <td>Yes</td>
                  <td>Insertion</td>
                  <td> </td>
                </tr>        

                <tr>
                  <td>Odd-Even</td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>1</td>
                  <td>Yes</td>
                  <td>Exchanging</td>
                  <td>Can be run on parallel processors easily</td>
                </tr>

                <tr>
                  <td>Patience</td>
                  <td><em>n</em></td>
                  <td> </td>
                  <td><em>n log n</em></td>
                  <td><em>n</em></td>
                  <td>No</td>
                  <td>Insertion &amp; Selection</td>
                  <td>Finds all the longest increasing subsequences in 
                      <em>O(n log n)</em></td>
                </tr>

                <tr>
                  <td>Shell</td>
                  <td><em>n log n</em></td>
                  <td><em>n log<sup>2</sup> n</em> or
                      <em>n<sup>5/4</sup></em></td>
                  <td>Depends on gap sequence; best known is 
                  <em>n log<sup>2</sup> n</em></td>
                  <td>1</td>
                  <td>No</td>
                  <td>Insertion</td>
                  <td>Small code size, no use of call stack,
                      reasonably fast, useful where memory is 
                      at a premium such as embedded and older 
                      mainframe applications. Best case 
                      <em>n log n</em> and worst case 
                      <em>n log<sup>2</sup> n</em> 
                      cannot be achieved together. With best case 
                      <em>n log n</em>, best worst case is 
                      <em>n<sup>4/3</sup></em></td>
                </tr>

                <tr>
                  <td>Smooth</td>
                  <td><em>n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td>1</td>
                  <td>No</td>
                  <td>Selection</td>
                  <td>An adaptive variant of heap sort based upon the Leonardo 
                      sequence rather than a traditional binary heap</td>
                </tr>

                <tr>
                  <td>Strand</td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n</em></td>
                  <td>Yes</td>
                  <td>Selection</td>
                  <td> </td>
                </tr>

                <tr>
                  <td>Tim</td>
                  <td><em>n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n</em></td>
                  <td>Yes</td>
                  <td>Insertion &amp; Merging</td>
                  <td>Makes <em>n</em> comparisons when the data is 
                      already sorted or reverse sorted</td>
                </tr>

                <tr>
                  <td>Tournament</td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n log n</em></td>
                  <td><em>n</em></td>
                  <td>No</td>
                  <td>Selection</td>
                  <td>Variation of heap sort</td>
                </tr>

                <tr>
                  <td>Unshuffle</td>
                  <td><em>n</em></td>
                  <td><em>kn</em></td>
                  <td><em>kn</em></td>
                  <td>In-place for linked list. <em>n x sizeof(link)</em> for array</td>
                  <td>No</td>
                  <td>Distribution &amp; Merge</td>
                  <td>No exchanges are performed.  The parameter <em>k</em>
                      is proportional to the entropy in the input.
                      <em>k = 1</em> for ordered or reverse ordered input</td>
                </tr>                
                </table>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-default" 
                        data-dismiss="modal">Close</button>
              </div>
            </div>
            <!-- /.modal-content -->
          </div>
          <!-- /.modal-dialog -->
        </div>
        <!-- /.modal --> 
        <!-- End Large modal -->        
               
        <a name="binary" id="binary"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Binary Tree Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A sort that builds a binary search tree from 
                the elements to be sorted, and then traverses the tree 
                (in-order) so that the elements come out in sorted order. Its 
                typical use is sorting elements adaptively: after each 
                insertion, the set of elements seen so far is available in 
                sorted order.</p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/comparison/BinaryTreeSort.java"
       target="_blank"> 
       BinaryTreeSort.java</a>                
            
<pre>
<code class="java">
public class BinaryTreeSort {
 // basic node stored in a tree
 class Node {
  public Object element;
  public Node leftChild;
  public Node rightChild;
  
  // constructor
  public Node(Object theElement) {
   this(theElement, null, null);
  }
  
  public Node(Object theElement, 
              Node lLink, 
              Node rLink) {
   element = theElement;
   this.leftChild = lLink;
   this.rightChild = rLink;
  }
 }        

 /**
  * has 1 constructor, which takes as 
  * parameter an object type root element 
  * will be the first element in the list
  * of elements to sort.
  **/
 public Node root;

 // constructor
 public BinaryTreeSort (Object x) { 
  root = new Node(x);
 }

 /**
  * add the new element in tree corresponding 
  * to the root, at each level it will check 
  * if the element to be added is smaller 
  * (move to left-subtree) or greater (move 
  * to right-subtree); and accordingly position 
  * decided.
  * @param node
  * @param x
  * @return 
  **/
 public Node insert(Node node, Integer x) {
  if (node == null) {
      return node = new Node(x);
  }
  if (x < (Integer) node.element) {
      node.leftChild = insert(node.leftChild, x);
  } else {
      node.rightChild = insert(node.rightChild, x);
  }
  return node;
 }

 /**
  * in-order traversal (left->root->right) of tree 
  * for getting elements in ascending order
  * @param node
  **/
 public void inOrder(Node node) {
  if (node != null) {
    inOrder(node.leftChild);
    System.out.print(((Integer) node.element)+ " ");
    inOrder(node.rightChild);
  }
 }

/** 
 * right->root->left traversal of tree for getting 
 * elements in descending order
 * @param node
 **/ 
 public void descendingOrder(Node node) {
 if (node != null) {
    descendingOrder(node.rightChild);
    System.out.print(((Integer) node.element)+ " ");
    descendingOrder(node.leftChild);
  }
 }

 public static void main(String[] args) {         
  // create an int array we want to 
  // sort using tree sort 
  int[] intArray = {24,2,45,20,56,75,2,56,99,53,12};
  BinaryTreeSort tree = new BinaryTreeSort(intArray[0]);
  for (int i = 1; i < intArray.length; i++) {
    tree.insert(tree.root,  intArray[i]);
  }

 // print array before sorting using tree sort 
 System.out.println("Array Before Tree Sort");
 for (int i = 0; i < intArray.length; i++) {
  System.out.print(intArray[i] + " ");
 }                     
 System.out.println(" ");

 // print array after sorting using tree sort
 System.out.print("After Tree Sort in Increasing Order: ");
 System.out.println(" ");
 tree.inOrder(tree.root);
 System.out.println(" ");
 System.out.print("After Tree Sort in Decreasing Order: ");
 System.out.println(" ");
 tree.descendingOrder(tree.root);            
 System.out.println(" ");
 }
}    
</code>    
</pre>

          </div>
        </div>
        
        <a name="block" id="block"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Block Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort combining at least two merge operations 
                with an insertion sort to arrive at O(n log n) in-place stable 
                sorting. It gets its name from the observation that merging two 
                sorted lists, A and B, is equivalent to breaking A into evenly 
                sized blocks, inserting each A block into B under special rules,
                and merging AB pairs.</p>

<pre>
<code>  
... 
</code>    
</pre>

          </div>
        </div>                
        
        <a name="cocktail" id="cocktail"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Cocktail Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A variation of bubble sort that is both a  
                stable sorting algorithm and a comparison sort. Differs from a 
                bubble sort in that it sorts in both directions on each pass 
                through the list. Only marginally more difficult to implement 
                than a bubble sort, and solves the problem of turtles in bubble 
                sorts. It provides only marginal performance improvements, and 
                does not improve asymptotic performance; like the bubble sort, 
                it is not of practical interest (insertion sort is preferred 
                for simple sorts), though it finds some use in education.</p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/comparison/CocktailSort.java"
       target="_blank"> 
       CocktailSort.java</a>                
            
<pre>
<code class="java">
public class CocktailSort {        
 public static void cocktailSort(int[] intArray) {
  boolean swapped;

  do {
    swapped = false;
    for (int i = 0; i <=  intArray.length - 2; i++) {
     if (intArray[ i ] > intArray[ i + 1 ]) {
        // test whether the two elements 
        // are in the wrong order
        int temp = intArray[i];
        intArray[i] = intArray[i + 1];
        intArray[i + 1]=temp;
        swapped = true;
     }
    }
    if (!swapped) {
        // we can exit the outer loop 
        // here if no swaps occurred.
        break;
    }

    swapped = false;
    for (int i = intArray.length - 2;i >= 0;i--) {
     if (intArray[ i ] > intArray[ i + 1 ]) {
        int temp = intArray[i];
        intArray[i] = intArray[i + 1];
        intArray[i + 1] = temp;
        swapped = true;
     }
    }
  // if no elements have been swapped, 
  // then the list is sorted
  } while (swapped);
 }
        
 public static void main(String[] args) {
   // create an int array we want to 
   // sort using cocktail sort
   int[] intArray = {24,2,45,20,56,75,2,56,99,53,12};

   // print array before sorting using cocktail sort
   System.out.println("Array Before Cocktail Sort");
   System.out.println(Arrays.toString(intArray));

   cocktailSort(intArray);

   // print array after sorting using cocktail sort 
   System.out.println("Array After Cocktail Sort");
   System.out.println(Arrays.toString(intArray));
 }
}
</code>    
</pre>

          </div>
        </div>                
        
        <a name="comb" id="comb"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Comb Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A relatively simple improvement on bubble sort.
                The basic idea is to eliminate turtles, or small values near the
                end of the list, since in a bubble sort these slow the sorting 
                down tremendously. (Rabbits, large values around the beginning 
                of the list, do not pose a problem in bubble sort). </p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/comparison/CombSort.java"
       target="_blank"> 
       CombSort.java</a>                
            
<pre>
<code class="java">
public class CombSort {
 // To find gap between elements
 int getNextGap(int gap) {
   gap = (gap * 10) / 13;
   // Shrink gap by Shrink factor
   if (gap < 1)
       return 1;
   return gap;
 }

 public static void main(String[] args) {               
  // create an int array we want to 
  // sort using comb sort 
  int A[] = new int[] {8,4,1,56,3,-44,23,-6,28,0};

  // print array before sorting using comb sort 
  System.out.println("Array Before Comb Sort");
  for (int i = 0; i< A.length; ++i)
    System.out.print(A[i] + " ");

  // sort an array using comb sort 
  CombSort ob = new CombSort();
  ob.combSort(A);

  System.out.println("");

  // print array after sorting using comb sort 
  System.out.println("Array After Comb Sort");
  for (int i = 0; i< A.length; ++i)
    System.out.print(A[i] + " ");
 }

 private void combSort(int A []) {                
  int n = A.length;
  // initialize gap
  int gap = n; 
  // Initialize swapped as true to make sure 
  // that loop runs
  boolean swapped = true; 
  /**
   * Keep running while gap is more than 1 and 
   * last iteration caused a swap
   **/ 
  while (gap != 1 || swapped == true)  {
    // Find next gap
    gap = getNextGap(gap); 
    /** 
     * Initialize swapped as false so that we 
     * can check if swap happened or not
     **/ 
    swapped = false; 
    // Compare all elements with current gap
    for (int i = 0; i < n - gap; i++) {
        if (A[i] > A[i + gap]) {                    
            // Swap A[i] and A[i+gap]
            int temp = A[i];
            A[i] = A[i + gap];
            A[i + gap] = temp; 
            // Set swapped
            swapped = true;
    }
   }
  }
 }
}
</code>    
</pre>

          </div>
        </div>
                        
        <a name="cube" id="cube"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Cube Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A parallel sort that builds a self-balancing 
                multi-dimensional array from the keys to be sorted. As the axes 
                are of similar length the structure resembles a cube. After each
                key is inserted the cube can be rapidly converted to an array. 
                It uses a specialized binary search on each axis to find the 
                location to insert an element. When an axis grows too large it 
                is split. Locality of reference is optimal as only four binary 
                searches are performed on small arrays for each insertion. By 
                using many small dynamic arrays the high cost for insertion on 
                single large arrays is avoided.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="cycle" id="cycle"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Cycle Sort</strong></div>
          <div class="card-body">
            <p class="card-text">An in-place unstable comparison sort that is 
                theoretically optimal in terms of the total number of writes to 
                the original array, unlike any other in-place sorting algorithm.
                It is based on the idea that the permutation to be sorted can be
                factored into cycles, which can individually be rotated to give 
                a sorted result.</p>
  
            <p>Unlike nearly every other sort, items are never written elsewhere
               in the array simply to push them out of the way of the action. 
               Each value is either written zero times, if it's already in its 
               correct position, or written one time to its correct position. 
               This matches the minimal number of overwrites required for a 
               completed in-place sort.</p>
  
            <p>Minimizing the number of writes is useful when making writes to 
                some huge data set is very expensive, such as with EEPROMs like 
                Flash memory where each write reduces the lifespan of the 
                memory.</p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/comparison/CycleSort.java"
       target="_blank"> 
       CycleSort.java</a>                
            
<pre>
<code class="java">
public class CycleSort {
 public static void main(String[] args) {
  // create an int array we want to 
  // sort using cycle sort 
  int intArray[] = new int[] {10,34,2,56,7,67,88,42,1,13};

  // print array before sorting using cycle sort
  System.out.println("Before Cycle Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
  }

  // sort an array using cycle sort 
  int writes = cycleSort(intArray);
  System.out.println("");

  // print array after sorting using cycle sort 
  System.out.println("After Cycle Sort");
  for (int i = 0; i < intArray.length; i++) {
    System.out.print(intArray[i] + " ");
  } 
  System.out.println("");
  System.out.println("Wrote: " + writes);
 }

 private static int cycleSort(int[] intArray) {
  int writes = 0;

  for (int cycleStart = 0; 
           cycleStart < intArray.length - 1; 
           cycleStart++) {
      int val = intArray[cycleStart];

    /**
     * Count the number of values that are 
     * smaller than val since cycleStart
     **/
    int pos = cycleStart;
    for (int i = cycleStart + 1; 
             i < intArray.length; i++) {
        if (intArray[i] < val) {
            pos++;
        }
    } 
    // there aren't any
    if (pos == cycleStart) {
        continue;
    }

    // Skip duplicates
    while (val == intArray[pos]) {
        pos++;
    }

    // Put val into final position
    int tmp = intArray[pos];
    intArray[pos] = val;
    val = tmp;
    writes++;

    /**
    * Repeat as long as we can find values 
    * to swap otherwise start new cycle
    **/
    while (pos != cycleStart) {
     pos = cycleStart;
     for (int i = cycleStart + 1; 
              i < intArray.length; i++) {
        if (intArray[i] < val) {
            pos++;
        }
     } 
     while (val == intArray[pos]) {
        pos++;
     } 
     tmp = intArray[pos];
     intArray[pos] = val;
     val = tmp;
     writes++;
    }        
   }            
  return writes;
 }
}
</code>    
</pre>

          </div>
        </div>
        
        <a name="fanceschinis" id="fanceschinis"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header">
              <strong>Fanceschinis Method Sort</strong></div>
          <div class="card-body">
            <p class="card-text">In-place sort for an array of size n that 
                performs, in the worst case, at most O(nlog n) element 
                comparisons and O(n) element transports. </p>

<pre>
<code>  
...
</code>    
</pre>
            
          </div>
        </div>
        
        <a name="gnome" id="gnome"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Gnome Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A "stupid sort" (not to be confused with 
                bogosort), and later described and named "gnome sort". It is a 
                sort which is similar to insertion sort, except that moving an 
                element to its proper place is accomplished by a series of 
                swaps, as in bubble sort (although some implementations use 
                series of swaps for both insertion and gnome sort, and these 
                algorithms are distinguished by gnome sort not immediately 
                inserting next item after inserting current item). It is 
                conceptually simple, requiring no nested loops. The average, or 
                expected, running time is O(n2), but tends towards O(n) if the 
                list is initially almost sorted.</p>
            
            <p>It always finds the first place where two adjacent elements are 
               in the wrong order, and swaps them. It takes advantage of the 
               fact that performing a swap can introduce a new out-of-order 
               adjacent pair only next to the two swapped elements. It does not 
               assume that elements forward of the current position are sorted, 
               so it only needs to check the position directly previous to the 
               swapped elements.</p>

<pre>
<code>  
...
</code>    
</pre>
          
          </div>
        </div>
        
        <a name="intro" id="intro"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Intro Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A hybrid sort that provides both fast average 
                performance and (asymptotically) optimal worst-case performance.
                It begins with quicksort and switches to heapsort when the 
                recursion depth exceeds a level based on (the logarithm of) the 
                number of elements being sorted. This combines the good parts 
                of both algorithms, with practical performance comparable to 
                quicksort on typical data sets and worst-case O(n log n) runtime
                due to the heap sort. Since both algorithms it uses are 
                comparison sorts, it too is a comparison sort.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="library" id="library"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Library Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort that uses an insertion sort, but with 
                gaps in the array to accelerate subsequent insertions. Like the 
                insertion sort it is based on, library sort is a stable 
                comparison sort and can be run as an online algorithm; however, 
                it was shown to have a high probability of running in O(n log n)
                time (comparable to quicksort), rather than an insertion sort's 
                O(n2). Compared to basic insertion sort, the drawback of library
                sort is that it requires extra space for the gaps. The amount 
                and distribution of that space would be implementation 
                dependent. In the paper the size of the needed array is 
                (1 + )n,[2] but with no further recommendations on how to 
                choose .</p>
            
            <p>One weakness of insertion sort is that it may require a high 
               number of swap operations and be costly if memory write is 
               expensive. Library sort may improve that somewhat in the 
               insertion step, as fewer elements need to move to make room, but 
               is also adding an extra cost in the rebalancing step. In 
               addition, locality of reference will be poor compared to 
               mergesort as each insertion from a random data set may access 
               memory that is no longer in cache, especially with large data 
               sets.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="odd" id="odd"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Odd-Even / Brick Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A relatively simple sort, developed originally
                for use on parallel processors with local interconnections. It 
                is a comparison sort related to bubble sort, with which it 
                shares many characteristics. It functions by comparing all 
                odd/even indexed pairs of adjacent elements in the list and, if 
                a pair is in the wrong order (the first is larger than the 
                second) the elements are switched. The next step repeats this 
                for even/odd indexed pairs (of adjacent elements). Then it 
                alternates between odd/even and even/odd steps until the list 
                is sorted.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>                                
        
        <a name="patience" id="patience"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Patience Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort algorithm inspired by, and named after,
                the card game patience. A variant of the algorithm efficiently 
                computes the length of a longest increasing subsequence in a 
                given array. </p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="shell" id="shell"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Shell Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> An in-place comparison sort. It can be seen 
                as either a generalization of sorting by exchange (bubble sort) 
                or sorting by insertion (insertion sort). The method starts by 
                sorting pairs of elements far apart from each other, then 
                progressively reducing the gap between elements to be compared. 
                Starting with far apart elements, it can move some out-of-place 
                elements into position faster than a simple nearest neighbor 
                exchange. Donald Shell published the first version of this sort 
                in 1959. The running time of Shellsort is heavily dependent on 
                the gap sequence it uses. For many practical variants, 
                determining their time complexity remains an open problem. </p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/comparison/ShellSort.java"
       target="_blank"> 
       ShellSort.java</a>                
            
<pre>
<code class="java">
import java.util.*;

public class ShellSort { 
 public static void main(String[] args) {
    // create an int array we want to 
    // sort using shell sort
    int intArray[] = new int[] 
        {61,109,149,111,34,2,24,119,122,125,27,145};
    
    // print array before sorting using shell sort 
    System.out.println("Before Shell Sort");
    System.out.println(Arrays.toString(intArray)); 

    // sort an array using shell sort 
    ShellSort ob = new ShellSort();
    ob.shellSort(intArray);

    // print array after sorting using shell sort 
    System.out.println("After Shell Sort");
    System.out.println(Arrays.toString(intArray)); 
 }

 private static void shellSort(int A []) { 
  int n = A.length;
/** 
 * Start with a larger gap, then reduce the 
 * gap to 1 take gap sequence in order of 
 * |N/2|, |N/4|, |N/8|...1
 **/
  for (int gap = n / 2; gap > 0; gap /= 2) {
    /** 
     * Perform gapped insertion sort for this 
     * gap size.The first gap elements
     * a[0..gap-1] are already in gapped order
     *  keep adding one more element until the 
     * entire array is gap sorted
     **/
    for (int i = gap; i < n; i += 1) { 
        // store a[i] in temp and make a hole 
        // at position i 
        int temp = A[i]; 
        /**
         * shift earlier gap-sorted elements up 
         * until the correct location for a[i] 
         * is found 
         **/ 
        int j; 
        for (j = i; j >= gap && A[j - gap] > temp;
             j -= gap)
            A[j] = A[j - gap];
        // put temp (the original a[i]) in its 
        // correct location
        A[j] = temp;
   }
  }
 }
}
</code>    
</pre>
 
          </div>
        </div>  
        
        <a name="smooth" id="smooth"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Smooth Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A comparison-based sort variant of heapsort, 
                it was invented and published by Edsger Dijkstra in 1981. Like 
                heapsort, it is an in-place sort with an upper bound of 
                O(n log n), but it is not a stable sort. The advantage is that 
                it comes closer to O(n) time if the input is already sorted to 
                some degree, whereas heapsort averages O(n log n) regardless of 
                the initial sorted state.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="strand" id="strand"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Strand Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A way of sorting numbers by extracting shorter 
                 sequences of already sorted numbers from an unsorted list.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>        
        
        <a name="tim" id="tim"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Tim Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A hybrid stable sort, derived from merge sort 
                and insertion sort, designed to perform well on many kinds of 
                real-world data. It was implemented by Tim Peters in 2002 for 
                use in the Python programming language. The algorithm finds 
                subsequences of the data that are already ordered, and uses 
                that knowledge to sort the remainder more efficiently. This is 
                done by merging an identified subsequence, called a run, with 
                existing runs until certain criteria are fulfilled. Timsort has 
                been Python's standard sorting algorithm since version 2.3. It 
                is also used to sort arrays of non-primitive type in Java SE 7, 
                on the Android platform, and in GNU Octave</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="tournament" id="tournament"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Tournament Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort that improves upon the naive selection 
                sort by using a priority queue to find the next element in the 
                sort. In the naive selection sort, it takes O(n) operations to 
                select the next element of n elements; in a tournament sort, 
                it takes O(log n) operations (after building the initial 
                tournament in O(n)). Tournament sort is a variation of 
                heapsort.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
        <a name="unshuffle" id="unshuffle"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Unshuffle Sort</strong></div>
          <div class="card-body">
            <p class="card-text">Unconventional technique is used mainly in 
                situations when the data is not readily available as arrays and 
                converting it into arrays becomes a costly business. It does 
                the sorting of linked lists, but in a very smart manner. It is 
                suitable for data chunks kept at different locations. Thus this 
                algorithm is very efficient in sorting streams of data. Its time
                complexity is one of the least among all existing sorting 
                algorithm. Also this is one of the rare sorting techniques 
                where the size of the elements to be sorted barely affects the 
                time complexity of the algorithm.</p>

<pre>
<code>  
...
</code>    
</pre>
            
          </div>
        </div>
        
<hr/>               
      
        <a name="noncomparison" id="noncomparison"></a>                               
        <h4>C.) Non Comparison Sorts </h4>
        <p> A non-comparison sort algorithm uses the internal character of the 
            values to be sorted. It can only be applied to some particular 
            cases, and requires particular values. And the best complexity is
            probably better depending on cases, such as <em>O(n)</em>.</p>  

        <!-- Large modal -->
        <!-- Trigger the modal with a button -->
        <button type="button" class="btn btn-primary" data-toggle="modal" 
                data-target="#myModal3">See Non Comparison Sort Table 
            <span class="fa fa-window-restore"></span>
        </button>
        <br/><br/>

        <!-- Non Comparison Sorts Modal -->
        <div id="myModal3" class="modal fade" role="dialog">
          <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <button type="button" class="close" 
                        data-dismiss="modal" aria-label="Close">
                    <span class="fa fa-window-close" aria-hidden="true"></span>
                </button>
                <h4 class="modal-title">Non Comparison Sorts</h4>
              </div>
              <div class="modal-body">

              <table class="table table-striped table-responsive">
                <!-- Table Headers -->  
                <tr>
                  <th>Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Best</th>
                  <th>Average&nbsp;&nbsp;</th>
                  <th>Worst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Memory</th>
                  <th>Stable</th>
                  <th>n&Lt;2<sup>k</sup></th>
                  <th>Notes</th>
                </tr>

                <tr>
                  <td>Bucket <sup>Integer Key</sup></td>
                  <td> </td>
                  <td><em>n + r</em></td>
                  <td><em>n + r</em></td>
                  <td><em>n + r</em></td>
                  <td>Yes</td>
                  <td>Yes</td>
                  <td>If <em>r</em> is <em>O(n)</em>, then average time complexity is 
                      <em>O(n)</em></td>
                </tr>

                <tr>
                  <td>Bucket <sup>Uniform Key</sup></td>
                  <td> </td>
                  <td><em>n + k</em></td>
                  <td><em>n<sup>2</sup> &ast; k</em></td>
                  <td><em>n &ast; k</em></td>
                  <td>Yes</td>
                  <td>No</td>
                  <td>Assumes uniform distribution of elements from the domain in the 
                      array</td>
                </tr>

                <tr>
                  <td>Burst</td>
                  <td> </td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * k/d</em></td>
                  <td>No</td>
                  <td>No</td>
                  <td>Has better constant factor than radix sort for sorting strings. 
                      Though relies somewhat on specifics of commonly encountered 
                      strings.</td>
                </tr>

                <tr>
                  <td>Flash</td>
                  <td><em>n</em></td>
                  <td><em>n + r</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td><em>n</em></td>
                  <td>No</td>
                  <td>No</td>
                  <td>Requires uniform distribution of elements from the domain in the 
                      array to run in linear time. If distribution is extremely skewed 
                      then it can go quadratic if underlying sort is quadratic (it is 
                      usually an insertion sort). In-place version is not stable.</td>
                </tr>

                <tr>
                  <td>LSD Radix</td>
                  <td> </td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * k/d</em></td>
                  <td><em>n + 2<sup>d</sup></em></td>
                  <td>Yes</td>
                  <td>No</td>
                  <td> </td>
                </tr>

                <tr>
                  <td>MSD Radix</td>
                  <td> </td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * k/d</em></td>
                  <td><em>n + 2<sup>d</sup></em></td>
                  <td>Yes</td>
                  <td>No</td>
                  <td>Stable version uses an external array of size n to hold all 
                      of the bins.</td>
                </tr>

                <tr>
                  <td>MSD Radix <sup>In-Place</sup></td>
                  <td> </td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * k/d</em></td>
                  <td><em>2<sup>d</sup></em></td>
                  <td>No</td>
                  <td>No</td>
                  <td><em>k/d</em> recursion level <em>2<sup>d</sup></em> for count 
                      array</td>
                </tr>

                <tr>
                  <td>Pigeonhole</td>
                  <td> </td>
                  <td><em>n + 2<sup>k</sup><em></td>
                  <td><em>n + 2<sup>k</sup><em></td>
                  <td><em>2<sup>k</sup></em></td>
                  <td>Yes</td>
                  <td>Yes</td>
                  <td> </td>
                </tr>

                <tr>
                  <td>Postman</td>
                  <td> </td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * k/d</em></td>          
                  <td><em>n + 2<sup>d</sup></em></td>
                  <td> </td>
                  <td>No</td>
                  <td>A variation of bucket sort, which works very similar to MSD Radix 
                      Sort. Specific to post service needs.</td>
                </tr>

                <tr>
                  <td>Spread</td>
                  <td><em>n</em></td>
                  <td><em>n * k/d</em></td>
                  <td><em>n * (k/s + d)</em></td>
                  <td><em>k/d * 2<sup>d</sup></em></td>
                  <td>No</td>
                  <td>No</td>
                  <td>Asymptotic are based on the assumption that n  2k, but the 
                      algorithm does not require this.</td>
                </tr>

                <tr>
                  <td>Sample</td>
                  <td colspan="7">https://en.wikipedia.org/wiki/Samplesort </td>
                </tr>

                </table>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">
                    Close
                </button>
              </div>
            </div>
            <!-- /.modal-content -->
          </div>
          <!-- /.modal-dialog -->
        </div>
        <!-- /.modal --> 
        <!-- End Large modal -->        

        <a name="bucket" id="bucket"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Bucket Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort that works by distributing the elements 
                of an array into a number of buckets. Each bucket is then sorted
                individually, either using a different sort, or by recursively 
                applying the bucket sort. It can be implemented with comparisons
                and therefore can also be considered a comparison sort. The 
                complexity estimates involve the number of buckets.</p>
            
            <p>Bucket Sort Integer Keys</p>
   
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/noncomparison/BucketSort.java"
       target="_blank"> 
       BucketSort.java</a>                
            
<pre>
<code class="java">
import java.util.*;

public class BucketSort {    
    
 public static void main(String[] args) {               
  // create an int array we want to sort using bucket sort 
  int intArray[] = new int[] 
                {8,4,1,56,3,44,23,6,28,8,4,1,5,3,44,3,6,28};
  // set max value
  int maxValue = 56;      

  // print array before sorting using bucket sort 
  System.out.println("Array Before Bucket Sort");
  System.out.println(Arrays.toString(intArray)); 

  // sort an array using bucket sort algorithm
  BucketSort ob = new BucketSort();
  ob.bucketSort(intArray, maxValue);

  System.out.println("");

  // print array after sorting using bucket sort 
  System.out.println("Array After Bucket Sort");
  System.out.println(Arrays.toString(intArray));         
 }    

 private void bucketSort(int intArray [], int maxValue) {                
  int n = intArray.length; 

  // create the bucket int array 
  int bucket[] = new int[maxValue + 1];

  // Go over the original array, putting each 
  // object in its bucket.
  for (int i = 0; i < bucket.length; i++) {
    bucket[i] = 0;
  } 
  // sort non-empty buckets
  for (int i = 0; i < n; i++) {
    bucket[intArray[i]]++;
  }
  // visit buckets in order and put all elements 
  // back into original array. 
  int outPos = 0;
  for (int i = 0; i < bucket.length; i++) {
   for (int j = 0; j < bucket[i]; j++) {
    intArray[outPos++] = i;
   }
  }
 }        
}   
</code>    
</pre>
           
          </div>
        </div>
        
        <a name="burst" id="burst"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Burst Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort that is cache-efficient for sorting 
                strings and is faster than radix sort for large data sets of 
                common strings.  It uses a trie to store prefixes of strings, 
                with growable arrays of pointers as end nodes containing sorted,
                unique, suffixes (referred to as buckets). Similar to MSD radix 
                sort, but its faster due to being aware of caching and related 
                radixes being stored closer to each other due to specifics of 
                trie structure. It exploits specifics of strings that are 
                usually encountered in the real world.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
            
        <a name="flash" id="flash"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Flash Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A sort that easily estimates where an 
                element should be placed after sorting when the range of the 
                set is known. It swaps places of the element based on the 
                sorting condition (ascending for example). </p>

<pre>
<code>  
...
</code>    
</pre>
           
          </div>
        </div>
        
        <a name="radix" id="radix"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Radix Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A  sort that sorts numbers by processing 
                individual digits. n numbers consisting of k digits each are 
                sorted in O(n  k) time. Radix sort can process digits of each 
                number either starting from the least significant digit (LSD) 
                or starting from the most significant digit (MSD).</p>  
                
            <p>The LSD algorithm first sorts the list by the least significant 
                digit while preserving their relative order using a stable sort.
                Then it sorts them by the next digit, and so on from the least 
                significant to the most significant, ending up with a sorted 
                list.</p>
                
            <p>While the LSD radix sort requires the use of a stable sort, the 
                MSD radix sort algorithm does not (unless stable sorting is 
                desired). In-place MSD radix sort is not stable. It is common 
                for the counting sort algorithm to be used internally by the 
                radix sort. A hybrid sorting approach, such as using insertion 
                sort for small bins improves performance of radix sort 
                significantly.</p>

    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/noncomparison/RadixSort.java"
       target="_blank"> 
       RadixSort.java</a>                
            
<pre>
<code class="java">
import java.util.*;

public class RadixSort {    
 // A utility function to get maximum value in intArray[]
 static int getMax(int intArray[], int n) {
  int max = intArray[0];
  for (int i = 1; i < n; i++)
    if (intArray[i] > max)
     max = intArray[i];
  return max;
 }
    
 public static void main(String[] args) {               
  // create an int array we want to sort using bucket sort 
  int intArray[] = new int[] 
             {8,4,1,56,3,44,23,6,28,8,4,1,5,423,44,3,6,28};
  // Driver function to check for above function
  int n = intArray.length;

  // print array before sorting using radix sort 
  System.out.println("Array Before Radix Sort");
  print(intArray, n); 

  // sort an array using radix sort 
  RadixSort ob = new RadixSort();
  ob.radixSort(intArray, n);

  System.out.println(" ");

  // print array after sorting using radix sort 
  System.out.println("Array After Radix Sort");
  print(intArray, n);         
 }    
    
 /** A function to do counting sort of intArray[] 
  *  according to the digit represented by exp.
  **/
 static void countSort(int intArray[], int n, int exp) {        
  // output array
  int output[] = new int[n]; 
  int count[] = new int[10];
  int i;
  Arrays.fill(count,0);

  // Store count of occurrences in count[]
  for (i = 0; i < n; i++)
    count[ (intArray[i] / exp) % 10 ]++;

  /** 
   * Change count[i] so that count[i] now 
   * contains actual position of  this 
   * digit in output[]
   **/ 
  for (i = 1; i < 10; i++)
    count[i] += count[i - 1]; 
  // Build the output array
  for (i = n - 1; i >= 0; i--) {
    output[count[(intArray[i] / exp) % 10 ] - 1] = intArray[i];
    count[(intArray[i] / exp)%10 ] --;
  }        
  /**
   * Copy the output array to intArray[], so that
   * intArray[] now contains sorted numbers 
   * according to current digit
   **/ 
    for (i = 0; i < n; i++)
        intArray[i] = output[i];
 }   

 // The main function to that sorts arr[] of 
 // size n using Radix Sort
 private void radixSort(int intArray [], int n) {                
  // Find the maximum number to know number 
  // of digits
  int m = getMax(intArray, n);

  /** 
   * Do counting sort for every digit. Note that 
   * instead of passing digit number, exp is 
   * passed. exp is 10^i where i is current digit
   * number
   **/ 
    for (int exp = 1; m / exp > 0; exp *= 10)
        countSort(intArray, n, exp);
    }

// A utility function to print an result array        
static void print(int intArray[], int n) {
  for (int i = 0; i < n; i++)
    System.out.print(intArray[i]+" ");
 }
} 
</code>    
</pre>

          </div>
        </div>
        
        <a name="pigeonhole" id="pigeonhole"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Pigeonhole Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A sort that is suitable for sorting lists of 
                elements where the number of elements (n) and the length of the 
                range of possible key values (N) are approximately the same. 
                It requires O(n + N) time. It is similar to counting sort, but 
                differs in that it "moves items twice: once to the bucket array 
                and again to the final destination [whereas] counting sort 
                builds an auxiliary array then uses the array to compute each 
                item's final destination and move the item there.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>

        <a name="postman" id="postman"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Postman Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A sort is a variant of bucket sort that takes 
                advantage of a hierarchical structure of elements, typically 
                described by a set of attributes. Used by letter-sorting 
                machines in post offices: mail is sorted first between domestic 
                and international; then by state, province or territory; then 
                by destination post office; then by routes, etc. Since keys are 
                not compared against each other, sorting time is O(cn), where c 
                depends on the size of the key and number of buckets. This is 
                similar to a radix sort that works "top down," or "most 
                significant digit first."</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>

        <a name="spread" id="spread"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Spread Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A sort that combines concepts from 
                distribution-based sorts, such as radix sort and bucket sort, 
                with partitioning concepts from comparison sorts such as 
                quicksort and mergesort. In experimental results it was shown 
                to be highly efficient, often outperforming traditional sorts 
                such as quicksort, particularly on distributions exhibiting 
                structure and string sorting.</p>
                
            <p>It generalizes this idea by partitioning the list into n/c 
                partitions at each step, where n is the total number of elements
                in the list and c is a small constant (in practice usually 
                between 4 and 8 when comparisons are slow, or much larger in 
                situations where they are fast). It uses distribution-based 
                techniques to accomplish this, first locating the minimum and 
                maximum value in the list, and then dividing the region between 
                them into n/c equal-sized bins. Where caching is an issue, it 
                can help to have a maximum number of bins in each recursive 
                division step, causing this division process to take multiple 
                steps. Though this causes more iterations, it reduces cache 
                misses and can make the sort run faster overall.</p>

            <p>In the case where the number of bins is at least the number of 
                elements, spreadsort degenerates to bucket sort and the sort 
                completes. Otherwise, each bin is sorted recursively. The sort 
                uses heuristic tests to determine whether each bin would be more
                efficiently sorted by spreadsort or some other classical sort, 
                then recursively sorts the bin.</p>

            <p>Like other distribution-based sorts, spreadsort has the weakness
                that the programmer is required to provide a means of converting
                each element into a numeric key, for the purpose of identifying 
                which bin it falls in. Although it is possible to do this for 
                arbitrary-length elements such as strings by considering each 
                element to be followed by an infinite number of minimum values, 
                and indeed for any datatype possessing a total order, this can 
                be more difficult to implement correctly than a simple 
                comparison function, especially on complex structures. Poor 
                implementation of this value function can result in clustering 
                that harms the algorithm's relative performance.</p>

<pre>
<code>  
...
</code>    
</pre>

            </p>
          </div>
        </div>

        <a name="sample" id="sample"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Sample Sort</strong></div>
          <div class="card-body">
            <p class="card-text"> A sort that is a divide and conquer sort often
                used in parallel processing systems. Conventional divide and 
                conquer sorting algorithms partitions the array into 
                sub-intervals or buckets. The buckets are then sorted 
                individually and then concatenated together. However, if the 
                array is non-uniformly distributed, the performance of these 
                sorting algorithms can be significantly throttled. Samplesort 
                addresses this issue by selecting a sample of size s from 
                the n-element sequence, and determining the range of the buckets
                by sorting the sample and choosing m -1 elements from the 
                result. These elements (called splitters) then divide the 
                sample into m equal-sized buckets.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>
        
<hr/>               
      
        <a name="other" id="other"></a>                               
        <h4>D.) Other Sorts </h4>
        <p>Most of these sorts are usually described for educational purposes in
           order to demonstrate how run time of algorithms is estimated. The 
           following describes some sorting algorithms that are impractical for 
           real-life use in traditional software contexts due to extremely poor 
           performance or specialized hardware requirements.</p>  

        <!-- Large modal -->
        <!-- Trigger the modal with a button -->
        <button type="button" class="btn btn-primary" data-toggle="modal" 
                data-target="#myModal4">See Other Sorts Table 
            <span class="fa fa-window-restore"></span>
        </button>
        <br/><br/>

        <!-- Other Sorts Modal -->
        <div id="myModal4" class="modal fade" role="dialog">
          <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <button type="button" class="close" 
                        data-dismiss="modal" aria-label="Close">
                    <span class="fa fa-window-close" aria-hidden="true"></span></button>
                <h4 class="modal-title">Other Sorts</h4>
              </div>
              <div class="modal-body">

              <table class="table table-striped table-responsive">
                <!-- Table Headers -->          
                <tr>
                  <th>Name</th>
                  <th>Best&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Average&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Worst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  <th>Stable</th>
                  <th>Comparison</th>
                  <th>Notes</th>
                </tr>

                <tr>
                  <td>Bead</td>
                  <td><em>n</em></td>
                  <td>S</td>
                  <td>S</td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>N/A</td>
                  <td>No</td>
                  <td>Works only with positive integers. Requires specialized hardware 
                      for it to run in guaranteed O(n) time. There is a possibility for 
                      software implementation, but running time will be O(S), where S 
                      is sum of all integers to be sorted, in case of small integers it 
                      can be considered to be linear.</td>
                </tr>

                <tr>
                  <td>Bitonic Sorter</td>
                  <td><em>log<sup>2</sup> n</em></td>
                  <td><em>log<sup>2</sup> n</em></td>
                  <td><em>log<sup>2</sup> n</em></td>
                  <td><em>n log<sup>2</sup> n</em></td>
                  <td>No</td>
                  <td>Yes</td>
                  <td>An effective variation of Sorting networks.</td>
                </tr>

                <tr>
                  <td>Bogo</td>
                  <td><em>n</em></td>
                  <td><em>(n x n!)</em></td>
                  <td><em>&infin;</em></td>
                  <td>1</td>
                  <td>No</td>
                  <td>Yes</td>
                  <td>Random shuffling. Used for example purposes only, as sorting with 
                      unbounded worst case running time.</td>
                </tr>

                <tr>
                  <td>Han's Algorithm</td>
                  <td colspan="7">Theoretical computer scientists have detailed Han's 
                      algorithm, a deterministic algorithm for sorting keys from a 
                      domain of finite size, taking O(n log log n) time and O(n) 
                      space.</td>
                </tr>

                <tr>
                  <td>Randomized Integer Sort</td>
                  <td colspan="7">Theoretical computer scientists have detailed
                      A randomized integer sorting algorithm taking 
                      O(n&Sqrt;log log n) expected time and O(n) space.</td>
                </tr>

                <tr>
                  <td>Simple Pancake</td>
                  <td> </td>
                  <td><em>n</em></td>
                  <td><em>n</em></td>
                  <td><em>log n</em></td>
                  <td>No</td>
                  <td>Yes</td>
                  <td>Count is number of flips.</td>
                </tr>

                <tr>
                  <td>Sorting Network</td>
                  <td><em>log<sup>2</sup> n</em></td>
                  <td><em>log<sup>2</sup> n</em></td>
                  <td><em>log<sup>2</sup> n</em></td>
                  <td><em>n log<sup>2</sup> n</em></td>
                  <td>Varies (stable sorting networks require more comparisons)</td>
                  <td>Yes</td>
                  <td>Order of comparisons are set in advance based on a fixed network 
                      size. Impractical for more than 32 items</td>
                </tr>

                <tr>
                  <td>Spaghetti</td>
                  <td><em>n</em></td>
                  <td><em>n</em></td>
                  <td><em>n</em></td>
                  <td><em>n<sup>2</sup></em></td>
                  <td>Yes</td>
                  <td>Polling</td>
                  <td>This is a linear-time, analog algorithm for sorting a sequence of 
                      items, requiring O(n) stack space, and the sort is stable. This 
                      requires n parallel processors.</td>
                </tr>

                <tr>
                  <td>Stooge</td>
                  <td><em>n<sup>log 3 / log 1.5</sup></em></td>
                  <td><em>n<sup>log 3 / log 1.5</sup></em></td>
                  <td><em>n<sup>log 3 / log 1.5</sup></em></td>
                  <td><em>n</em></td>
                  <td>No </td>
                  <td>Yes</td>
                  <td>Slower than most of the sorting algorithms (even naive ones) with 
                      a time complexity of O(n<sup>log 3 / log 1.5</sup>) = O(n<sup>2.7095...</sup>)</td>
                </tr>

                <tr>
                  <td>Thorup's Algorithm</td>
                  <td colspan="7">Theoretical computer scientists have detailed 
                      Thorup's Algorithm as a randomized algorithm for sorting keys from a domain 
                      of finite size, taking O(n log log n) time and O(n) space.</td>
                </tr>

                </table>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
              </div>
            </div>
           <!-- /.modal-content -->
          </div>
         <!-- /.modal-dialog -->
        </div>
        <!-- /.modal --> 
        <!-- End Large modal -->        

        <a name="bead" id="bead"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Bead Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A natural sort that is also called gravity 
                sort, published in The Bulletin of the European Association for 
                Theoretical Computer Science. Both digital and analog hardware 
                implementations of bead sort can achieve a sorting time of O(n);
                however, the implementation of this algorithm tends to be 
                significantly slower in software and can only be used to sort 
                lists of positive integers. Also, it would seem that even in 
                the best case, the algorithm requires O(n2) space.</p>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>        
        
        <a name="bitonic" id="bitonic"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Bitonic Sorter</strong></div>
          <div class="card-body">
            <p class="card-text">A classic parallel sort for O(n Log 2n) 
                comparisons. The number of comparisons done are more than 
                popular sorts like Merge Sort [ does O(nLogn) comparisons], but
                better for parallel implementation because we always compare 
                elements in predefined sequence and the sequence of comparison 
                doesnt depend on data. Therefore it is suitable for 
                implementation in hardware and parallel processor array. However,
                to understand, we must first understand what a Bitonic Sequence 
                is and how to make a given sequence Bitonic.</p>
   
    See <span class="fa fa-file-code"></span></a>
    <a href="https://github.com/keeyanajones/Java-Sorting-Algorithms/blob/master/src/other/BitonicSort.java"
       target="_blank"> 
       BitonicSort.java</a>                
            
<pre>
<code class="java">
/** 
 * Java program for Bitonic Sort. Note that this program
 * works only when size of input is a power of 2. 
 **/
public class BitonicSort {
  /** The parameter dir indicates the sorting direction,
   *  ASCENDING or DESCENDING; if (a[i] > a[j]) agrees
   *  with the direction, then a[i] and a[j] are
   *  interchanged. 
   **/
  void compAndSwap(int a[], int i, int j, int dir)    {
    if ( (a[i] > a[j] && dir == 1) ||
         (a[i] < a[j] && dir == 0)) {
            // Swapping elements
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
         }
  }
 
  /** It recursively sorts a bitonic sequence in ascending
   *  order, if dir = 1, and in descending order otherwise
   *  (means dir=0). The sequence to be sorted starts at
   *  index position low, the parameter cnt is the number
   *  of elements to be sorted.
   **/
  void bitonicMerge(int a[], int low, int cnt, int dir)   {
    if (cnt>1)   {
        int k = cnt / 2;
        for (int i = low; i < low + k; i++)
            compAndSwap(a,i, i+k, dir);
        bitonicMerge(a,low, k, dir);
        bitonicMerge(a,low + k, k, dir);
    }
  }
 
  /** This function first produces a bitonic sequence by
   * recursively sorting its two halves in opposite sorting
   * orders, and then  calls bitonicMerge to make them in
   * the same order 
   **/
  void bitonicSort(int a[], int low, int cnt, int dir) {
    if (cnt>1)  {
      int k = cnt/2;
 
      // sort in ascending order since dir here is 1
      bitonicSort(a, low, k, 1);
 
      // sort in descending order since dir here is 0
      bitonicSort(a,low+k, k, 0);
 
      // Will merge wole sequence in ascending order
      // since dir=1.
      bitonicMerge(a, low, cnt, dir);
   }
 }
 
  /**
   * Caller of bitonicSort for sorting the entire 
   * array of length N in ASCENDING order 
   **/
  void sort(int a[], int N, int up)   {
     bitonicSort(a, 0, N, up);
  }
 
  /**
   * A utility function to print array of size n 
   **/
  static void printArray(int arr[]) {
      int n = arr.length;
      for (int i = 0; i < n; ++i)
          System.out.print(arr[i] + " ");
      System.out.println();
  }
 
  // Driver method
  public static void main(String args[]) {
      int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
      int up = 1;
      BitonicSort ob = new BitonicSort();
      ob.sort(a, a.length,up);
      System.out.println("\nSorted array");
      printArray(a);
  }
}
</code>    
</pre>

          </div>
        </div>        
        
        <a name="bogo" id="bogo"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Bogo Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A permutation sort, stupid sort, slowsort, 
                shotgun sort or monkey sort is a highly ineffective sorting 
                function based on the generate and test paradigm. The function 
                successively generates permutations of its input until it finds 
                one that is sorted. It is not useful for sorting, but may be
                used for educational purposes, to contrast it with more 
                efficient algorithms.</p>
            
            <p>Two versions of the function exist: </p>
               <ol> 
                  <li>a deterministic version that enumerates all permutations 
                      until it hits a sorted one</li> 
                
                  <li>a randomized version that randomly permutes its input</li>
                </ol>
            <p>An analogy for the working of the latter version is to sort a 
                deck of cards by throwing the deck into the air, picking the 
                cards up at random, and repeating the process until the deck is 
                sorted. Its name comes from the word bogus.</p>

<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>        
                
        <a name="hans" id="hans"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Han's Algorithm</strong></div>
          <div class="card-body">
            <p class="card-text">A deterministic algorithm for sorting keys 
                from a domain of finite size, taking O(n log log n) time and 
                O(n) space.</p>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>          
        
        <a name="thorups" id="thorups"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Thorup's Algorithm</strong></div>
          <div class="card-body">
            <p class="card-text">A randomized algorithm for sorting keys from a 
                domain of finite size, taking O(n log log n) time and O(n) 
                space.</p>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>                

        <a name="randomized" id="randomized"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header">
              <strong>Randomized Integer Sorting Algorithm</strong></div>
          <div class="card-body">
            <p class="card-text">A integer sorting algorithm taking 
                <em>O(n&Sqrt;log log n)</em> expected time and <em>O(n)</em> space</p>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>          
        
        <a name="simple" id="simple"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Simple Pancake Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort is the colloquial term for the 
                mathematical problem of sorting a disordered stack of pancakes 
                in order of size when a spatula can be inserted at any point in 
                the stack and used to flip all pancakes above it. A pancake 
                number is the minimum number of flips required for a given 
                number of pancakes. </p>
            <p>It is a variation of the sorting problem in which the only 
                allowed operation is to reverse the elements of some prefix of 
                the sequence. Unlike a traditional sorting algorithm, which 
                attempts to sort with the fewest comparisons possible, the goal 
                is to sort the sequence in as few reversals as possible. A 
                variant of the problem is concerned with burnt pancakes, where 
                each pancake has a burnt side and all pancakes must, 
                in addition, end up with the burnt side on bottom.            
            </p>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>        
        
        <a name="sortingnetwork" id="sortingnetwork"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Sorting Network</strong></div>
          <div class="card-body">
            <p class="card-text">A abstract devices built up of a fixed number 
                of "wires", carrying values, and comparator modules that connect
                pairs of wires, swapping the values on the wires if they are 
                not in a desired order. Such networks are typically designed to 
                perform sorting on fixed numbers of values.</p>

            <p>They differ from general comparison sorts in that they are not 
               capable of handling arbitrarily large inputs, and in that their 
               sequence of comparisons is set in advance, regardless of the 
               outcome of previous comparisons. This independence of comparison 
               sequences is useful for parallel execution and for implementation
               in hardware. Despite the simplicity of sorting nets, their theory
               is surprisingly deep and complex.</p> 
                            
            <p>They can also be implemented either in hardware or in software. 
               Since the 2000s, sorting nets (especially bitonic mergesort) are 
               used by the GPGPU community for constructing sorting algorithms 
               to run on graphics processing units.            
            </p>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>  
        
        <a name="spaghetti" id="spaghetti"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Spaghetti Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort that is a linear-time, analog algorithm 
                for sorting a sequence of items, it sorts a sequence of items 
                requiring O(n) stack space in a stable manner. It requires a 
                parallel processor. Assume we are sorting a list of natural 
                numbers. The sorting method is illustrated using uncooked rods 
                of spaghetti:</p>
              <ul>
                <li>For each number x in the list, obtain a rod of length x. 
                    (One practical way of choosing the unit is to let the largest 
                    number m in the list correspond to one full rod of spaghetti. 
                    In this case, the full rod equals m spaghetti units. To get a 
                    rod of length x, break a rod in two so that one piece is of 
                    length x units; discard the other piece.)</li>
                <li>Once you have all your spaghetti rods, take them loosely in 
                    your fist and lower them to the table, so that they all 
                    stand upright, resting on the table surface. Now, for each 
                    rod, lower your other hand from above until it meets with a 
                    rodthis one is clearly the longest. Remove this rod and 
                    insert it into the front of the (initially empty) output 
                    list (or equivalently, place it in the last unused slot of 
                    the output array). Repeat until all rods have been removed.
                </li>                                
              </ul>
<pre>
<code>  
...
</code>    
</pre>

          </div>
        </div>        
        
        <a name="stooge" id="stooge"></a>
        <div class="card text-white bg-dark mb-3" style="max-width: 100%;">
          <div class="card-header"><strong>Stooge Sort</strong></div>
          <div class="card-body">
            <p class="card-text">A sort that is a recursive sorting algorithm 
                with a time complexity of O(nlog 3 / log 1.5 ) = O(n2.7095...). 
                The running time of the algorithm is thus slower compared to 
                efficient sorting algorithms, such as Merge sort, and is even 
                slower than Bubble sort, a canonical example of a fairly 
                inefficient and simple sort. The algorithm is defined as 
                follows:
            </p>    
            
            <ul>
              <li>If the value at the start is larger than the value at the end,
                  swap them.</li>
              <li>If there are 3 or more elements in the list, then:</li>
              <ul>
                <li>Stooge sort the initial 2/3 of the list</li>
                <li>Stooge sort the final 2/3 of the list</li>
                <li>Stooge sort the initial 2/3 of the list again</li>
              </ul>
            </ul>
            
            <p>It is important to get the integer sort size used in the 
                recursive calls by rounding the 2/3 upwards, e.g. rounding 2/3 
                of 5 should give 4 rather than 3, as otherwise the sort can 
                fail on certain data. However, if the code is written to end on 
                a base case of size 1, rather than terminating on either size 1 
                or size 2, rounding the 2/3 of 2 upwards gives an infinite 
                number of calls.                   
            </p>
            
<pre>
<code>  
...
</code>    
</pre>
            
      </div>
      </div>    
      
<hr/>

        <h3><a name="take-five" class="anchor" href="#take-five">
          <span class="header-link"></span></a>
          Review</h3>
          
        <p>Alright, let's recap what I've just learned:</p>
    
        <ul>
            <li>There a numerous types of sorts, generally that put elements in 
                a certain order these include:</li>          
            <ul>
              <li>in place</li>
              <li>stable</li>
              <li>adaptive</li>
              <li>common</li>
              <li>comparison</li>
              <li>non comparison</li>              
              <li>other (theoretical)</li>              
            </ul>
        </ul>
        
    <p>You can read more at: 
        <a href="https://go.java/" target="_blank">
           <small>https://go.java</small></a></p>

      <!-- pagination -->
       <a role="button" class="btn btn-primary pull-left"  
               href="../index.html">
            &larr; PREVIOUS: Algorithms</a>
          
      <a role="button" class="btn btn-primary pull-right" 
              href="../../uml/index.html">
            NEXT: Unified Modeling Language (UML) &rarr;</a><br/><br/>
    </section>
        
    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" 
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" 
            crossorigin="anonymous"></script>         
    <script src="../../assets/javascripts/scale.fix.js"></script>
  </body>
</html>

      