<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Code Journal: Design Patterns</title>   
    <!-- Latest compiled and minified CSS -->     
    <!-- Font Awesome 5.0.13 -->     
    <link rel="stylesheet" 
          href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" 
          integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" 
          crossorigin="anonymous">         
    <!-- Bootstrap 3.3.7 --> 
    <link rel="stylesheet" 
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
          crossorigin="anonymous">
    <!-- Highlight.js 9.13.1 -->     
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/androidstudio.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>    
    <script>hljs.initHighlightingOnLoad();</script>          
    
    <!-- Custom Style Pygment and Icons -->     
    <link rel="stylesheet" href="../assets/stylesheets/styles.css">
    <link rel="stylesheet" href="../assets/stylesheets/pygment_trac.css">
    <link rel="icon" href="../assets/images/favicon.ico" type="image/gif">
    <link rel="shortcut icon" href="../assets/images/favicon.png">    
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  
  <body>
    <div class="wrapper">               
    <!-- Header -->         
      <header>
          <img src="../assets/images/pb_Image.png" class="img-fluid" alt="me"/>
        <p class="view">A Code Journal for 
            <span class="fab fa-git-square" aria-hidden="true"></span>
                Hub Pages<br/>        
                
            <a href="https://github.com/keeyanajones/Journal" target="_blank">
            <span class="fab fa-github"></span> 
              View the Code Journal on GitHub</a></p>
                      
                        
            <button class="btn btn-md btn-default" type="button">
                <span class="fab fa-java fa-2x"></span> 
            </button>                
            
            <button class="btn btn-md btn-default" type="button">
                <span class="fab fa-python fa-2x"></span> 
            </button>                        

            <button class="btn btn-md btn-default" type="button">
                <span class="fab fa-r-project  fa-2x"></span> 
            </button>                
            
            <button class="btn btn-md btn-default" type="button">
            <span class="fab fa-js fa-2x"></span> 
            </button>                              

            <br/><br/>
            
            <a href="https://github.com/keeyanajones/">
            <small><span class="fab fa-github-alt"></span>                 
            Repositories and latest Contribution Activity</small></a>                 
              
        <br/>
        
        <!-- Download, Clone, or Fork -->
        <ul>    
          <li><a href="https://github.com/keeyanajones/Journal/archive/master.zip">
              <span class="fa fa-file-archive" aria-hidden="true"></span><br/>
                  Download <br/> ZIP</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-clone" aria-hidden="true"></span><br/>
                  Clone <br/> Desktop</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-code-branch" aria-hidden="true"></span><br/>
                  Fork On <br/> GitHub</a></li>
        </ul>                                 
      </header>
    <!-- ./header --> 
    </div>          
      
    <section>
        <h2><span class="fa fa-object-group " aria-hidden="true"></span>
              <a name="design-patterns" class="anchor" href="#design-paterns">
              <span class="header-link"></span></a>
          Design Patterns <sup>in Java</sup></h2>                  
     
        <p><sup><span class="fa fa-calendar"></span>
                Last updated on January 2nd, 2019</sup></p>
                                           
        <ol class="breadcrumb">
            <li><span class="fa fa-bookmark"></span> 
                <a href="../index.html">Home</a></li>
            <li class="active"><a href="#design-patterns">
                <span class="fa fa-bookmark"></span>  
                 Design Patterns <sup>in Java</sup></a></li>
        </ol>
                                 
        <a name="patterns" id="patterns"></a>            
        <p>Design patterns represent the best practices used by experienced 
           object-oriented software developers. Design patterns are solutions 
           to general problems that software developers faced during software 
           development. These solutions were obtained by trial and error by 
           numerous software developers over quite a substantial period of 
           time.</p>

        <h3>What is Gang of Four (GOF)?</h3>
        <p>In 1994, four authors Erich Gamma, Richard Helm, Ralph Johnson and 
           John Vlissides published a book titled Design Patterns - Elements of 
           Reusable Object-Oriented Software which initiated the concept of 
           Design Pattern in Software development.</p>

        <p>These authors are collectively known as Gang of Four (GOF). 
           According to these authors design patterns are primarily based on 
           the following principles of object orientated design.</p>

        <ul>
          <li>Program to an interface not an implementation</li>  
          <li>Favor object composition over inheritance</li>
        </ul>

        <h4>Usage of Design Pattern</h4>
        <p>Design Patterns have two main usages in software development.</p>

        <h5>Common platform for developers</h5>
        <p>Design patterns provide a standard terminology and are specific to 
           particular scenario. For example, a singleton design pattern 
           signifies use of single object so all developers familiar with single
           design pattern will make use of single object and they can tell each 
           other that program is following a singleton pattern.</p>

        <h5>Best Practices</h5>
        <p>Design patterns have been evolved over a long period of time and they
           provide best solutions to certain problems faced during software 
           development. Learning these patterns helps unexperienced developers 
           to learn software design in an easy and faster way.</p>

        <h5>Types of Design Patterns</h5>
        <p>As per the design pattern reference book Design Patterns - Elements 
           of Reusable Object-Oriented Software , there are 33 design patterns 
           which can be classified in four categories: Creational, Structural 
           and Behavioral patterns. We'll also discuss another category of 
           design pattern: J2EE design patterns.</p>

        <ul>
          <li><a href="#creational">Creational Patterns</a>
                                  : These design patterns provide a way to 
                                    create objects while hiding the creation 
                                    logic, rather than instantiating objects 
                                    directly using new operator. This gives 
                                    program more flexibility in deciding which 
                                    objects need to be created for a given use 
                                    case.</li>
          <li><a href="#structural">Structural Patterns</a>
                                    : These design patterns concern class and 
                                    object composition. Concept of inheritance 
                                    is used to compose interfaces and define 
                                    ways to compose objects to obtain new 
                                    functionalities.</li>
          <li><a href="#behavioral">Behavioral Patterns</a> 
                                    : These design patterns are specifically 
                                    concerned with communication between 
                                    objects.</li>
          <li><a href="#j2ee">J2EE Patterns</a> 
                            : These design patterns are specifically concerned 
                              with the presentation tier. These patterns are 
                              identified by Sun Java Center.</li>
        </ul>
        
        <hr/>
        
        <a name="creational" id="creational"></a>
        <h3>Creational Patterns</h3>
        <ul>        
          <li><a href="#factory">Factory</a> 
                        : Define an interface for creating a single object, but 
                        let subclasses decide which class to instantiate. 
                        Factory Method lets a class defer instantiation to 
                        subclasses.</li>
          <li><a href="#abstractfactory">Abstract Factory </a>
                        : Provide an interface for creating families of 
                                 related or dependent objects without specifying
                                 their concrete classes.</li>
          <li><a href="#singleton">Singleton</a> 
                        :  Ensure a class has only one instance, and provide a 
                           global point of access to it.</li>
          <li><a href="#builder">Builder</a>   
                        :  Separate the construction of a complex object from 
                           its representation, allowing the same construction 
                           process to create various representations.</li>
          <li><a href="#prototype">Prototype</a>
                        :  Specify the kinds of objects to create using a 
                           prototypical instance, and create new objects from 
                           the 'skeleton' of an existing object, thus boosting 
                           performance and keeping memory footprints to a 
                           minimum.</li>
        </ul>
<!---
Dependency Injection	A class accepts the objects it requires from an injector instead of creating the objects directly.	
Lazy initialization	Tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed. This pattern appears in the GoF catalog as "virtual proxy", an implementation strategy for the Proxy pattern.	
Multiton                Ensure a class has only named instances, and provide a global point of access to them.	
Object pool             Avoid expensive acquisition and release of resources by recycling objects that are no longer in use. Can be considered a generalisation of connection pool and thread pool patterns.	
Resource acquisition is initialization (RAII)	Ensure that resources are properly released by tying them to the lifespan of suitable objects.	
--->


        <a name="factory" id="factory"></a>
        <h5>Factory Pattern</h5>
        <p>Factory pattern is one of the most used design patterns in Java. This
           type of design pattern comes under creational pattern as this pattern
           provides one of the best ways to create an object.</p>

        <p>In Factory pattern, we create object without exposing the creation 
           logic to the client and refer to newly created object using a common 
           interface.</p>

        <h5>Implementation</h5>
        <p>We're going to create a Shape interface and concrete classes 
           implementing the Shape interface. A factory class ShapeFactory is 
           defined as a next step.</p>

        <h5>When to use</h5>
        <ul>
          <li>When you don't know ahead of time what class object you need</li>  
          <li>When all of the potential classes are in the same subclass 
              hierarchy</li>
          <li>To centralize class selection code</li>
          <li>When you don't want the user to have to know every subclass</li>
          <li>To encapsulate object creation</li>
        </ul>
        
        <p>FactoryPattern, our demo class will use ShapeFactory to get a 
           Shape object. It will pass information (CIRCLE / RECTANGLE / SQUARE) 
           to ShapeFactory to get the type of object it needs.</p>

        <img src="../assets/images/factoryPatternDiagram.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/factory/Shape.java"
           target="_blank"> 
        Shape.java</a>                

<pre>
<code>
public interface Shape {
   void draw();
}
</code>
</pre>

        <p><strong>Step 2</strong> <br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/factory/Rectangle.java"
           target="_blank"> 
         Rectangle.java</a>                        

<pre>
<code>
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/factory/Square.java"
           target="_blank"> 
           Square.java</a>                            
    
<pre>
<code>
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/factory/Circle.java"
           target="_blank"> 
           Circle.java</a>                        

<pre>
<code>
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create a Factory to generate object of concrete class based on given 
        information.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/factory/ShapeFactory.java"
           target="_blank"> 
           ShapeFactory.java</a>                                
      
<pre>
<code>
public class ShapeFactory {	
   //use getShape method to get object of type shape 
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }		
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
         
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
         
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      
      return null;
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the Factory to get object of concrete class by passing an 
        information such as type.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/factory/FactoryPattern.java"
           target="_blank"> 
          FactoryPattern.java</a>                                
        
<pre>
<code>
public class FactoryPattern {
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      //get an object of Circle and call its draw method.
      Shape shape1 = shapeFactory.getShape("CIRCLE");

      //call draw method of Circle
      shape1.draw();

      //get an object of Rectangle and call its draw method.
      Shape shape2 = shapeFactory.getShape("RECTANGLE");

      //call draw method of Rectangle
      shape2.draw();

      //get an object of Square and call its draw method.
      Shape shape3 = shapeFactory.getShape("SQUARE");

      //call draw method of circle
      shape3.draw();
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
</code>
</pre>

        <hr/>

        <a name="abstractfactory" id="abstractfactory"></a>
        <h5>Abstract Factory Pattern</h5>
        <p>Abstract Factory patterns work around a super-factory which creates 
           other factories. This factory is also called as factory of factories. 
           This type of design pattern comes under creational pattern as this 
           pattern provides one of the best ways to create an object.</p>

        <p>In Abstract Factory pattern an interface is responsible for creating 
           a factory of related objects without explicitly specifying their 
           classes. Each generated factory can give the objects as per the 
           Factory pattern.</p>

        <h5>Implementation</h5>
        <p>We are going to create a Shape and Color interfaces and concrete 
           classes implementing these interfaces. We create an abstract factory 
           class AbstractFactory as next step. Factory classes ShapeFactory and 
           ColorFactory are defined where each factory extends AbstractFactory. 
           A factory creator/generator class FactoryProducer is created.</p>

        <h5>When to use</h5>
        <ul>
          <li>Having many object that can be added or changed dynamically 
              during runtime</li>  
        </ul>
        
        <p>AbstractFactoryPattern, our demo class uses FactoryProducer to 
           get a AbstractFactory object. It will pass information 
           (CIRCLE / RECTANGLE / SQUARE for Shape) to AbstractFactory to get 
           the type of object it needs. It also passes information 
           (RED / GREEN / BLUE for Color) to AbstractFactory to get the type of 
           object it needs.</p>

        <img src="../assets/images/abstractFactoryPatternDiagram.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface for Shapes.</p>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Shape.java"
           target="_blank"> 
          Shape.java</a>                                        
        
<pre>
<code>
public interface Shape {
   void draw();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Rectangle.java"
           target="_blank"> 
          Rectangle.java</a>                                        
        
<pre>
<code>
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Square.java"
           target="_blank"> 
          Square.java</a>                                        
        
<pre>
<code>
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Circle.java"
           target="_blank"> 
          Circle.java</a>                                        
        
<pre>
<code>
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create an interface for Colors.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Color.java"
           target="_blank"> 
          Color.java</a>                                        
                
<pre>
<code>
public interface Color {
   void fill();
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create concrete classes implementing the same interface.</p>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Red.java"
           target="_blank"> 
          Red.java</a>                                        

<pre>
<code>
public class Red implements Color {
   @Override
   public void fill() {
      System.out.println("Inside Red::fill() method.");
   }
}
</code>
</pre>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Green.java"
           target="_blank"> 
           Green.java</a>                                        
        
<pre>
<code>
public class Green implements Color {
   @Override
   public void fill() {
      System.out.println("Inside Green::fill() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/Blue.java"
          target="_blank"> 
           Blue.java</a>                                        
        
<pre>
<code>
public class Blue implements Color {
   @Override
   public void fill() {
      System.out.println("Inside Blue::fill() method.");
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Create an Abstract class to get factories for Color and Shape 
        Objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/AbstractFactory.java"
           target="_blank"> 
          AbstractFactory.java</a>                                        
                
<pre>
<code>
public abstract class AbstractFactory {
   abstract Color getColor(String color);
   abstract Shape getShape(String shape) ;
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Create Factory classes extending AbstractFactory to generate object of 
        concrete class based on given information.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/ShapeFactory.java"
           target="_blank"> 
          ShapeFactory.java</a>                                        
                
<pre>
<code>
public class ShapeFactory extends AbstractFactory {	
   @Override
   public Shape getShape(String shapeType){
   
      if(shapeType == null){
         return null;
      }		
      
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
         
      }else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
         
      }else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      
      return null;
   }
   
   @Override
   Color getColor(String color) {
      return null;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/ColorFactory.java"
           target="_blank"> 
          ColorFactory.java</a>                                        
        
<pre>
<code>
public class ColorFactory extends AbstractFactory {	
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   Color getColor(String color) {
   
      if(color == null){
         return null;
      }		
      
      if(color.equalsIgnoreCase("RED")){
         return new Red();
         
      }else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
         
      }else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      
      return null;
   }
}
</code>
</pre>

        <p><strong>Step 7</strong><br/>
        Create a Factory generator/producer class to get factories by passing 
        an information such as Shape or Color</p>

        See <span class="fa fa-file-code"></span>
       <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/FactoryProducer.java"
          target="_blank"> 
          FactoryProducer.java</a>                                        
                
<pre>
<code>
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
   
      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
         
      }else if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }
      
      return null;
   }
}
</code>
</pre>

        <p><strong>Step 8</strong><br/>
        Use the FactoryProducer to get AbstractFactory in order to get factories
        of concrete classes by passing an information such as type.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/abstractfactory/AbstractFactoryPattern.java"
           target="_blank"> 
           AbstractFactoryPattern.java</a>
            
<pre>
<code>
public class AbstractFactoryPattern {
   public static void main(String[] args) {
      //get shape factory
      AbstractFactory shapeFactory = 
                      FactoryProducer.getFactory("SHAPE");

      //get an object of Shape Circle
      Shape shape1 = shapeFactory.getShape("CIRCLE");

      //call draw method of Shape Circle
      shape1.draw();

      //get an object of Shape Rectangle
      Shape shape2 = shapeFactory.getShape("RECTANGLE");

      //call draw method of Shape Rectangle
      shape2.draw();
      
      //get an object of Shape Square 
      Shape shape3 = shapeFactory.getShape("SQUARE");

      //call draw method of Shape Square
      shape3.draw();

      //get color factory
      AbstractFactory colorFactory = 
                      FactoryProducer.getFactory("COLOR");

      //get an object of Color Red
      Color color1 = colorFactory.getColor("RED");

      //call fill method of Red
      color1.fill();

      //get an object of Color Green
      Color color2 = colorFactory.getColor("Green");

      //call fill method of Green
      color2.fill();

      //get an object of Color Blue
      Color color3 = colorFactory.getColor("BLUE");

      //call fill method of Color Blue
      color3.fill();
   }
}
</code>
</pre>

        <p><strong>Step 9</strong><br/>
        Verify the output.</p>

<pre>
<code>
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.        
</code>
</pre>        
        
        <hr/>
        
        <a name="singleton" id="singleton"></a>
        <h5>Singleton Pattern</h5>  
        <p>Singleton pattern is one of the simplest design patterns in Java. 
           This type of design pattern comes under creational pattern as this 
           pattern provides one of the best ways to create an object.</p>

        <p>This pattern involves a single class which is responsible to create 
           an object while making sure that only single object gets created. 
           This class provides a way to access its only object which can be 
           accessed directly without need to instantiate the object of the 
           class.</p>

        <h5>Implementation</h5>
        <p>We're going to create a SingleObject class. SingleObject class have 
           its constructor as private and have a static instance of itself.</p>

        <h5>When to use</h5>        
        <ul>
          <li>Eliminate the option of instantiating more than one object</li>
        </ul>
            
        <p>SingleObject class provides a static method to get its static 
           instance to outside world. SingletonPattern, our demo class will 
           use SingleObject class to get a SingleObject object.</p>

        <img src="../assets/images/singletonPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create a Singleton Class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/singleton/SingleObject.java"
           target="_blank"> 
           SingleObject.java</a>
                
<pre>
<code>
public class SingleObject {
   //create an object of SingleObject
   private static SingleObject instance = new SingleObject();

   //make the constructor private so that this class cannot be
   //instantiated
   private SingleObject(){}

   //Get the only object available
   public static SingleObject getInstance(){
      return instance;
   }

   public void showMessage(){
      System.out.println("Hello World!");
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Get the only object from the singleton class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/singleton/SingletonPattern.java"
           target="_blank"> 
           SingletonPattern.java</a>
                
<pre>
<code>
public class SingletonPattern {
   public static void main(String[] args) {
      //illegal construct
      //Compile Time Error: The constructor SingleObject() is not visible
      //SingleObject object = new SingleObject();

      //Get the only object available
      SingleObject object = SingleObject.getInstance();

      //show the message
      object.showMessage();
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Verify the output.</p>

<pre>
<code>
Hello World!        
</code>
</pre>        

    <hr/>

        <a name="builder" id="builder"></a>
        <h5>Builder Pattern</h5>
        <p>Builder pattern builds a complex object using simple objects and 
           using a step by step approach. This type of design pattern comes 
           under creational pattern as this pattern provides one of the best 
           ways to create an object.</p>

        <p>A Builder class builds the final object step by step. This builder 
            is independent of other objects.</p>
        
        <h5>Implementation</h5>
        <p>We have considered a business case of fast-food restaurant where a 
           typical meal could be a burger and a cold drink. Burger could be 
           either a Veg Burger or Chicken Burger and will be packed by a 
           wrapper. Cold drink could be either a coke or pepsi and will be 
           packed in a bottle.</p>

        <p>We are going to create an Item interface representing food items 
           such as burgers and cold drinks and concrete classes implementing 
           the Item interface and a Packing interface representing packaging 
           of food items and concrete classes implementing the Packing interface
           as burger would be packed in wrapper and cold drink would be packed 
           as bottle.</p>

        <h5>When to use</h5>        
        <ul>
          <li>To build an object made up from other objects</li>
          <li>The creation of these parts to be independent of the main 
              object</li>
          <li>Hide the creation of the parts from the client so both are not 
              dependent</li>
          <li>The builder knows the specifics and nobody else does</li>
        </ul>
        
        <p>We then create a Meal class having ArrayList of Item and a 
           MealBuilder to build different types of Meal objects by combining 
           Item. BuilderPattern, our demo class will use MealBuilder to 
           build a Meal.</p>

        <img src="../assets/images/builderPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface Item representing food item and packing.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Item.java"
           target="_blank"> 
           Item.java</a>        
        
<pre>
<code>
public interface Item {
   public String name();
   public Packing packing();
   public float price();	
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Packing.java"
           target="_blank"> 
           Packing.java</a>        
        
<pre>
<code>
public interface Packing {
   public String pack();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the Packing interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Wrapper.java"
           target="_blank"> 
           Wrapper.java</a>
    
<pre>
<code>
public class Wrapper implements Packing {
   @Override
   public String pack() {
      return "Wrapper";
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Bottle.java"
           target="_blank"> 
           Bottle.java</a>
<pre>
<code>
public class Bottle implements Packing {
   @Override
   public String pack() {
      return "Bottle";
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create abstract classes implementing the item interface providing 
        default functionalities.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Burger.java"
           target="_blank"> 
           Burger.java</a>
    
<pre>
<code>
public abstract class Burger implements Item {
   @Override
   public Packing packing() {
      return new Wrapper();
   }

   @Override
   public abstract float price();
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/ColdDrink.java"
           target="_blank"> 
           ColdDrink.java</a>
    
<pre>
<code>
public abstract class ColdDrink implements Item {
	@Override
	public Packing packing() {
       return new Bottle();
	}

	@Override
	public abstract float price();
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create concrete classes extending Burger and ColdDrink classes</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/VegBurger.java"
           target="_blank"> 
           VegBurger.java</a>
    
<pre>
<code>
public class VegBurger extends Burger {
   @Override
   public float price() {
      return 25.0f;
   }

   @Override
   public String name() {
      return "Veg Burger";
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/ChickenBurger.java"
           target="_blank"> 
           ChickenBurger.java</a>
    
<pre>
<code>
public class ChickenBurger extends Burger {
   @Override
   public float price() {
      return 50.5f;
   }

   @Override
   public String name() {
      return "Chicken Burger";
   }
}
</code>
</pre>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Coke.java"
           target="_blank"> 
           Coke.java</a>
    
<pre>
<code>
public class Coke extends ColdDrink {
   @Override
   public float price() {
      return 30.0f;
   }

   @Override
   public String name() {
      return "Coke";
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Pepsi.java"
           target="_blank"> 
           Pepsi.java</a>
    
<pre>
<code>
public class Pepsi extends ColdDrink {
   @Override
   public float price() {
      return 35.0f;
   }

   @Override
   public String name() {
      return "Pepsi";
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Create a Meal class having Item objects defined above.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/Meal.java"
           target="_blank"> 
           Meal.java</a>
    
<pre>
<code>
import java.util.ArrayList;
import java.util.List;

public class Meal {
   private List<Item> items = new ArrayList<>();	

   public void addItem(Item item){
      items.add(item);
   }

   public float getCost(){
      float cost = 0.0f;
      
      for (Item item : items) {
         cost += item.price();
      }		
      return cost;
   }

   public void showItems(){   
      for (Item item : items) {
         System.out.print("Item : " + item.name());
         System.out.print(", Packing : " 
               + item.packing().pack());
         System.out.println(", Price : " 
               + item.price());
      }		
   }	
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Create a MealBuilder class, the actual builder class responsible to 
        create Meal objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/MealBuilder.java"
           target="_blank"> 
           MealBuilder.java</a>
        
<pre>
<code>
public class MealBuilder {
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   

   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
</code>
</pre>

        <p><strong>Step 7</strong><br/>
        BuiderPattern uses MealBuider to demonstrate builder pattern.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/builder/BuilderPattern.java"
           target="_blank"> 
           BuilderPattern.java</a>
<pre>
<code>
public class BuilderPattern {
   public static void main(String[] args) {   
      MealBuilder mealBuilder = new MealBuilder();

      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println("Veg Meal");
      vegMeal.showItems();
      System.out.println("Total Cost: " + vegMeal.getCost());

      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println("\n\nNon-Veg Meal");
      nonVegMeal.showItems();
      System.out.println("Total Cost: " + nonVegMeal.getCost());
   }
}
</code>
</pre>

        <p><strong>Step 8</strong><br/>
        Verify the output.</p>

<pre>
<code>
Veg Meal
Item : Veg Burger, Packing : Wrapper, Price : 25.0
Item : Coke, Packing : Bottle, Price : 30.0
Total Cost: 55.0

Non-Veg Meal
Item : Chicken Burger, Packing : Wrapper, Price : 50.5
Item : Pepsi, Packing : Bottle, Price : 35.0
Total Cost: 85.5
</code>
</pre>
     
        <hr/>

        <a name="prototype" id="prototype"></a>
        <h5>Prototype Pattern</h5>
        <p>Prototype pattern refers to creating duplicate object while keeping 
           performance in mind. This type of design pattern comes under 
           creational pattern as this pattern provides one of the best ways 
           to create an object.</p>

        <p>This pattern involves implementing a prototype interface which tells 
           to create a clone of the current object. This pattern is used when 
           creation of object directly is costly. For example, an object is to 
           be created after a costly database operation. We can cache the 
           object, returns its clone on next request and update the database as 
           and when needed thus reducing database calls.</p>

        <h5>Implementation</h5>
        <p>We're going to create an abstract class Shape and concrete classes 
           extending the Shape class. A class ShapeCache is defined as a next 
           step which stores shape objects in a Hashtable and returns their 
           clone when requested.</p>

        <h5>When to use</h5>        
        <ul>
          <li>There are numerous potential classes that you want to only use 
              if needed at runtime</li>
        </ul>        
        
        <p>PrototypPattern, our demo class will use ShapeCache class to get 
           a Shape object.</p>

        <img src="../assets/images/prototypePattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an abstract class implementing Cloneable interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/prototype/Shape.java"
           target="_blank"> 
          Shape.java</a>
    
<pre>
<code>
public abstract class Shape implements Cloneable {   
   private String id;
   protected String type;
   
   abstract void draw();
   
   public String getType(){
      return type;
   }
   
   public String getId() {
      return id;
   }
   
   public void setId(String id) {
      this.id = id;
   }
   
   public Object clone() {
      Object clone = null;
      
      try {
         clone = super.clone();
         
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      
      return clone;
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes extending the above class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/prototype/Rectangle.java"
           target="_blank"> 
          Rectangle.java</a>
        
<pre>
<code>
public class Rectangle extends Shape {
   public Rectangle(){
     type = "Rectangle";
   }

   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/prototype/Square.java"
           target="_blank"> 
          Square.java</a>
    
<pre>
<code>
public class Square extends Shape {
   public Square(){
     type = "Square";
   }

   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/prototype/Circle.java"
           target="_blank"> 
          Circle.java</a>
    
<pre>
<code>
public class Circle extends Shape {
   public Circle(){
     type = "Circle";
   }

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create a class to get concrete classes from database and store them 
        in a Hashtable.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/prototype/ShapeCache.java"
           target="_blank"> 
          ShapeCache.java</a>
    
<pre>
<code>
import java.util.Hashtable;

public class ShapeCache {
	
   private static Hashtable<String, Shape> shapeMap  = 
       new Hashtable<String, Shape>();

   public static Shape getShape(String shapeId) {
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone();
   }

   // for each shape run database query and create shape
   // shapeMap.put(shapeKey, shape);
   // for example, we are adding three shapes
   
   public static void loadCache() {
      Circle circle = new Circle();
      circle.setId("1");
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId("2");
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId("3");
      shapeMap.put(rectangle.getId(), rectangle);
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        PrototypePattern uses ShapeCache class to get clones of shapes 
        stored in a Hashtable.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/creational/prototype/PrototypePattern.java"
           target="_blank"> 
          PrototypePattern.java</a>
    
<pre>
<code>
public class PrototypePattern {
   public static void main(String[] args) {
      ShapeCache.loadCache();

      Shape clonedShape = (Shape) ShapeCache.getShape("1");
      System.out.println("Shape : " + clonedShape.getType());		

      Shape clonedShape2 = (Shape) ShapeCache.getShape("2");
      System.out.println("Shape : " + clonedShape2.getType());		

      Shape clonedShape3 = (Shape) ShapeCache.getShape("3");
      System.out.println("Shape : " + clonedShape3.getType());		
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>
        
<pre>
<code>
Shape : Circle
Shape : Square
Shape : Rectangle        
</code>
</pre>     

        <hr/>
        
        <a name="structural" id="structural"></a>
        <h3>Structural Patterns</h3>

        <ul>
          <li><a href="#adapter">Adapter, Wrapper, or Translator</a>
                        : Convert the interface of a class into another 
                          interface clients expect. An adapter lets classes 
                          work together that could not otherwise because of 
                          incompatible interfaces. The enterprise integration 
                          pattern equivalent is the translator.</li>
          <li><a href="#bridge">Bridge</a>
                      : Decouple an abstraction from its implementation allowing 
                      the two to vary independently.</li>
          <li><a href="#filter">Filter or Criteria</a>
                                : Enables filtering a set of objects using 
                                  different criteria and chaining them in a 
                                  decoupled way through logical operations. This
                                  type of design pattern comes under structural 
                                  pattern as this pattern combines multiple 
                                  criteria to obtain single criteria.</li>
          <li><a href="#composite">Composite</a>
                        : Compose objects into tree structures to represent 
                         part-whole hierarchies. Composite lets clients treat 
                         individual objects and compositions of objects 
                         uniformly.</li>
          <li><a href="#decorator">Decorator</a>
                        : Attach additional responsibilities to an object 
                         dynamically keeping the same interface. Decorators 
                         provide a flexible alternative to subclassing for 
                         extending functionality.</li>
          <li><a href="#facade">Facade</a>
                     : Provide a unified interface to a set of interfaces in a 
                      subsystem. Facade defines a higher-level interface that 
                      makes the subsystem easier to use.</li>
          <li><a href="#flyweight">Flyweight</a>
                     : Use sharing to support large numbers of similar objects
                         efficiently.</li>
          <li><a href="#proxy">Proxy</a>
                     : Provide a surrogate or placeholder for another object to 
                     control access to it.</li>
        </ul>        
     
<!---
Extension object :	Adding functionality to a hierarchy without changing the hierarchy.	No	No	Agile Software Development, Principles, Patterns, and Practices[15]
Front controller:	The pattern relates to the design of Web applications. It provides a centralized entry point for handling requests.	No	No	J2EE Patterns[16] PoEAA[17]
Marker	: Empty interface to associate metadata with a class.	No	No	Effective Java[18]
Module	: Group several related elements, such as classes, singletons, methods, globally used, into a single conceptual entity.	No	No	N/A
Twin :	Twin allows modeling of multiple inheritance in programming languages that do not support this feature.	No	No	N/A        
--->        
 
        <a name="adapter" id="adapter"></a>
        <h5>Adapter, Wrapper, or Translator Pattern</h5>
        <p>Adapter pattern works as a bridge between two incompatible 
           interfaces. This type of design pattern comes under structural 
           pattern as this pattern combines the capability of two independent 
           interfaces.</p>

        <p>This pattern involves a single class which is responsible to join 
           functionalities of independent or incompatible interfaces. A real 
           life example could be a case of card reader which acts as an adapter 
           between memory card and a laptop. You plugin the memory card into 
           card reader and card reader into the laptop so that memory card can 
           be read via laptop.</p>

        <p>We are demonstrating use of Adapter pattern via following example in 
           which an audio player device can play mp3 files only and wants to use 
           an advanced audio player capable of playing vlc and mp4 files.</p>

        <h5>Implementation</h5>
        <p>We have a MediaPlayer interface and a concrete class AudioPlayer 
           implementing the MediaPlayer interface. AudioPlayer can play mp3 
           format audio files by default.</p>

        <p>We are having another interface AdvancedMediaPlayer and concrete 
           classes implementing the AdvancedMediaPlayer interface. These classes 
           can play vlc and mp4 format files.</p>

        <p>We want to make AudioPlayer to play other formats as well. To attain 
           this, we have created an adapter class MediaAdapter which implements 
           the MediaPlayer interface and uses AdvancedMediaPlayer objects to 
           play the required format.</p>

        <h5>When to use</h5>        
        <ul>
          <li>The client expects a (target) interface</li>    
        </ul>
        
        <p>AudioPlayer uses the adapter class MediaAdapter passing it the 
           desired audio type without knowing the actual class which can play 
           the desired format. AdapterPatternDemo, our demo class will use 
           AudioPlayer class to play various formats.</p>

        <img src="../assets/images/adapterPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create interfaces for Media Player and Advanced Media Player.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/MediaPlayer.java"
           target="_blank"> 
          MediaPlayer.java</a>
    
<pre>
<code>
public interface MediaPlayer {
   public void play(String audioType, String fileName);
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/AdvancedMediaPlayer.java"
           target="_blank"> 
          AdvancedMediaPlayer.java</a>
    
<pre>
<code>
public interface AdvancedMediaPlayer {	
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the AdvancedMediaPlayer 
        interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/VlcPlayer.java"
           target="_blank"> 
          VicPlayer.java</a>
        
<pre>
<code>
public class VlcPlayer implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      System.out.println("Playing vlc file. Name: "+ fileName);		
   }

   @Override
   public void playMp4(String fileName) {
      //do nothing
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/Mp4Player.java"
           target="_blank"> 
          Mp4Player.java</a>
    
<pre>
<code>
public class Mp4Player implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      //do nothing
   }

   @Override
   public void playMp4(String fileName) {
      System.out.println("Playing mp4 file. Name: "+ fileName);		
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create adapter class implementing the MediaPlayer interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/MediaAdapter.java"
           target="_blank"> 
          MediaAdapter.java</a>
    
<pre>
<code>
public class MediaAdapter implements MediaPlayer {
   AdvancedMediaPlayer advancedMusicPlayer;

   public MediaAdapter(String audioType){   
      if(audioType.equalsIgnoreCase("vlc") ){
         advancedMusicPlayer = new VlcPlayer();			
         
      }else if (audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer = new Mp4Player();
      }	
   }

   @Override
   public void play(String audioType, String fileName) {
   
      if(audioType.equalsIgnoreCase("vlc")){
         advancedMusicPlayer.playVlc(fileName);
      }
      else if(audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create concrete class implementing the MediaPlayer interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/AudioPlayer.java"
           target="_blank"> 
          AudioPlayer.java</a>
    
<pre>
<code>
public class AudioPlayer implements MediaPlayer {
   MediaAdapter mediaAdapter; 

   @Override
   public void play(String audioType, String fileName) {		
      //inbuilt support to play mp3 music files
      if(audioType.equalsIgnoreCase("mp3")){
         System.out.println("Playing mp3 file. Name: " 
                + fileName);			
      } 
      
      //mediaAdapter is providing support to play 
      //other file formats
      else if(audioType.equalsIgnoreCase("vlc") || 
              audioType.equalsIgnoreCase("mp4")){
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      }
      
      else{
         System.out.println("Invalid media. " 
            + audioType + 
                    " format not supported");
      }
   }   
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Use the AudioPlayer to play different types of audio formats.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/adapter/AdapterPattern.java"
           target="_blank"> 
          AdapterPattern.java</a>
    
<pre>
<code>
public class AdapterPattern {
   public static void main(String[] args) {
      AudioPlayer audioPlayer = new AudioPlayer();

      audioPlayer.play("mp3", "beyond the horizon.mp3");
      audioPlayer.play("mp4", "alone.mp4");
      audioPlayer.play("vlc", "far far away.vlc");
      audioPlayer.play("avi", "mind me.avi");
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Verify the output.</p>

<pre>
<code>
Playing mp3 file. Name: beyond the horizon.mp3
Playing mp4 file. Name: alone.mp4
Playing vlc file. Name: far far away.vlc
Invalid media. avi format not supported
</code>
</pre> 

        <hr/>

        <a name="bridge" id="bridge"></a>
        <h5>Bridge Pattern</h5>
        
        <p>Bridge is used when we need to decouple an abstraction from its 
           implementation so that the two can vary independently. This type 
           of design pattern comes under structural pattern as this pattern 
           decouples implementation class and abstract class by providing a 
           bridge structure between them.</p>

        <p>This pattern involves an interface which acts as a bridge which 
           makes the functionality of concrete classes independent from 
           interface implementer classes. Both types of classes can be altered 
           structurally without affecting each other.</p>

        <p>We are demonstrating use of Bridge pattern via following example in 
           which a circle can be drawn in different colors using same abstract 
           class method but different bridge implementer classes.</p>

        <h5>Implementation</h5>
        <p>We have a DrawAPI interface which is acting as a bridge implementer 
           and concrete classes RedCircle, GreenCircle implementing the DrawAPI 
           interface. Shape is an abstract class and will use object of DrawAPI. 
           BridgePatternDemo, our demo class will use Shape class to draw 
           different colored circle.</p>
        
        <h5>When to use</h5>
        <ul>
            <li>To be able to change both the abstractions (abstract classes)
                and concrete classes independently</li>
            <li>The first abstraction class to define rules</li>
            <li>The concrete class adds additional rules</li>
            <li>An abstract class has a reference to the device and it defines
                abstract methods that will be defined</li>
            <li>The concrete remote defines the abstract methods required</li>
        </ul>
        
        <img src="../assets/images/bridgePattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create bridge implementer interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/bridge/DrawAPI.java"
           target="_blank"> 
          DrawAPI.java</a>
    
<pre>
<code>
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete bridge implementer classes implementing the DrawAPI 
        interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/bridge/RedCircle.java"
           target="_blank"> 
          RedCircle.java</a>
    
<pre>
<code>
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle [color: red, radius: " 
           + radius + ", x: " + x + ", " + y + "]");
   }
}
</code>
</pre>
 
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/bridge/GreenCircle.java"
           target="_blank"> 
          GreenCircle.java</a>
    
<pre>
<code>        
public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle [color: green, radius: " 
           + radius + ", x: " + x + ", " + y + "]");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create an abstract class Shape using the DrawAPI interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/bridge/Shape.java"
           target="_blank"> 
          Shape.java</a>
    
<pre>
<code>        
public abstract class Shape {
   protected DrawAPI drawAPI;
   
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();	
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create concrete class implementing the Shape interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/bridge/Circle.java"
           target="_blank"> 
          Circle.java</a>
    
<pre>
<code>        
public class Circle extends Shape {
   private int x, y, radius;

   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }

   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Use the Shape and DrawAPI classes to draw different colored circles.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/bridge/BridgePattern.java"
           target="_blank"> 
          BridgePattern.java</a>
    
<pre>
<code>        
public class BridgePattern {
   public static void main(String[] args) {
      Shape redCircle = 
           new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = 
           new Circle(100,100, 10, new GreenCircle());

      redCircle.draw();
      greenCircle.draw();
   }
}
</code>
</pre>
        
        <p><strong>Step 6</strong><br/>
        Verify the output.</p>
        
<pre>
<code>
Drawing Circle [color: red, radius: 10, x: 100, 100]
Drawing Circle [color: green, radius: 10, x: 100, 100]        
</code>
</pre> 
        
        <hr/>
       
        <a name="filter" id="filter"></a>
        <h5>Filter Pattern</h5>
        <p>Filter pattern or Criteria pattern is a design pattern that enables 
           developers to filter a set of objects using different criteria and 
           chaining them in a decoupled way through logical operations. This 
           type of design pattern comes under structural pattern as this pattern 
           combines multiple criteria to obtain single criteria.</p>

        <h5>Implementation</h5>
        <p>We're going to create a Person object, Criteria interface and 
           concrete classes implementing this interface to filter list of Person
           objects. CriteriaPatternDemo, our demo class uses Criteria objects to
           filter List of Person objects based on various criteria and their 
           combinations.</p>
        
        <h5>When to use</h5>
        <ul>
          <li>Have a requirement where you want to add filters dynamically</li> 
          <li>Implementing multiple functionalities and most of them require 
              different filter criteria to filter something</li>  
        </ul>
        
        <img src="../assets/images/filterPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create a class on which criteria is to be applied.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/Person.java"
           target="_blank"> 
          Person.java</a>

<pre>
<code>        
public class Person {
   private String name;
   private String gender;
   private String maritalStatus;

   public Person(String name, 
                 String gender, 
                 String maritalStatus){
      this.name = name;
      this.gender = gender;
      this.maritalStatus = maritalStatus;		
   }

   public String getName() {
      return name;
   }
   public String getGender() {
      return gender;
   }
   public String getMaritalStatus() {
      return maritalStatus;
   }	
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create an interface for Criteria.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/Criteria.java"
           target="_blank"> 
          Criteria.java</a>

<pre>
<code>        
import java.util.List;

public interface Criteria {
   public List<Person> meetCriteria(List<Person> persons);
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create concrete classes implementing the Criteria interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/CriteriaMale.java"
           target="_blank"> 
          CriteriaMale.java</a>

<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class CriteriaMale implements Criteria {

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> malePersons = new ArrayList<Person>(); 
      
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase("MALE")){
            malePersons.add(person);
         }
      }
      return malePersons;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/CriteriaFemale.java"
           target="_blank"> 
          CriteriaFemale.java</a>

<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class CriteriaFemale implements Criteria {

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> femalePersons = new ArrayList<Person>(); 
      
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase("FEMALE")){
            femalePersons.add(person);
         }
      }
      return femalePersons;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/CriteriaSingle.java"
           target="_blank"> 
          CriteriaSingle.java</a>

<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class CriteriaSingle implements Criteria {
 @Override
  public List<Person> meetCriteria(List<Person> persons) {
   List<Person> singlePersons = new ArrayList<Person>(); 
      
   for (Person person : persons) {
    if(person.getMaritalStatus().equalsIgnoreCase("SINGLE")){
       singlePersons.add(person);
    }
   }
  return singlePersons;
 }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/AndCriteria.java"
           target="_blank"> 
          AndCriteria.java</a>

<pre>
<code>        
import java.util.List;

public class AndCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public AndCriteria(Criteria criteria, 
                      Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
   
      List<Person> firstCriteriaPersons = 
              criteria.meetCriteria(persons);		
      return otherCriteria.meetCriteria(firstCriteriaPersons);
   }
}
</code>
</pre>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/OrCriteria.java"
           target="_blank"> 
          OrCriteria.java</a>

<pre>
<code>        
import java.util.List;

public class OrCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public OrCriteria(Criteria criteria, 
                     Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> firstCriteriaItems = 
          criteria.meetCriteria(persons);
      List<Person> otherCriteriaItems = 
          otherCriteria.meetCriteria(persons);

      for (Person person : otherCriteriaItems) {
         if(!firstCriteriaItems.contains(person)){
            firstCriteriaItems.add(person);
         }
      }	
      return firstCriteriaItems;
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use different Criteria and their combination to filter out persons.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/filter/CriteriaPattern.java"
           target="_blank"> 
          CriteriaPattern.java</a>

<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class CriteriaPattern {
  public static void main(String[] args) {
    List<Person> persons = new ArrayList<Person>();

      persons.add(new Person("Robert","Male", "Single"));
      persons.add(new Person("John", "Male", "Married"));
      persons.add(new Person("Laura", "Female", "Married"));
      persons.add(new Person("Diana", "Female", "Single"));
      persons.add(new Person("Mike", "Male", "Single"));
      persons.add(new Person("Bobby", "Male", "Single"));

      Criteria male = new CriteriaMale();
      Criteria female = new CriteriaFemale();
      Criteria single = new CriteriaSingle();
      Criteria singleMale = new AndCriteria(single, male);
      Criteria singleOrFemale = new OrCriteria(single, female);

      System.out.println("Males: ");
      printPersons(male.meetCriteria(persons));

      System.out.println("\nFemales: ");
      printPersons(female.meetCriteria(persons));

      System.out.println("\nSingle Males: ");
      printPersons(singleMale.meetCriteria(persons));

      System.out.println("\nSingle Or Females: ");
      printPersons(singleOrFemale.meetCriteria(persons));
  }

  public static void printPersons(List<Person> persons){
    for (Person person : persons) {
      System.out.println("Person : [ 
        Name : " + person.getName() + ", 
        Gender : " + person.getGender() + ", 
        Marital Status : " + person.getMaritalStatus() + " ]");
    }
  }      
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>        
Males: 
Person : [ Name : Robert, Gender : Male, 
           Marital Status : Single ]
Person : [ Name : John, Gender : Male, 
           Marital Status : Married ]
Person : [ Name : Mike, Gender : Male, 
           Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, 
           Marital Status : Single ]

Females: 
Person : [ Name : Laura, Gender : Female, 
           Marital Status : Married ]
Person : [ Name : Diana, Gender : Female, 
           Marital Status : Single ]

Single Males: 
Person : [ Name : Robert, Gender : Male, 
           Marital Status : Single ]
Person : [ Name : Mike, Gender : Male, 
           Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, 
           Marital Status : Single ]

Single Or Females: 
Person : [ Name : Robert, Gender : Male, 
           Marital Status : Single ]
Person : [ Name : Diana, Gender : Female, 
           Marital Status : Single ]
Person : [ Name : Mike,  Gender : Male, 
           Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, 
           Marital Status : Single ]
Person : [ Name : Laura, Gender : Female, 
           Marital Status : Married ]        
</code>
</pre>        
     
        <hr/>
        
        <a name="composite" id="composite"></a>
        <h5>Composite Pattern</h5>        
        <p>Composite pattern is used where we need to treat a group of objects 
           in similar way as a single object. Composite pattern composes objects 
           in term of a tree structure to represent part as well as whole 
           hierarchy. This type of design pattern comes under structural pattern
           as this pattern creates a tree structure of group of objects.</p>

        <p>This pattern creates a class that contains group of its own objects. 
           This class provides ways to modify its group of same objects.</p>

        <p>We are demonstrating use of composite pattern via following example 
           in which we will show employees hierarchy of an organization.</p>

        <h5>Implementation</h5>
        <p>We have a class Employee which acts as composite pattern actor class. 
           CompositePatternDemo, our demo class will use Employee class to add 
           department level hierarchy and print all employees.</p>

        <img src="../assets/images/compositePattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Employee class having list of Employee objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/composite/Employee.java"
           target="_blank"> 
          Employee.java</a>
    
<pre>
<code> 
import java.util.ArrayList;
import java.util.List;

public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List<Employee> subordinates;

   // constructor
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList<Employee>();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List<Employee> getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return ("Employee: [Name: " + name + ", "
              + "Dept: " + dept + ", "
              + "Salary: $" + salary+"]");
   }   
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Use the Employee class to create and print employee hierarchy.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/composite/CompositePattern.java"
           target="_blank"> 
          CompositePattern.java</a>
    
<pre>
<code>
public class CompositePattern {
  public static void main(String[] args) {
   
    Employee CEO = 
       new Employee("John","CEO", 30000);

    Employee headSales = 
       new Employee("Robert","Head Sales", 20000);

    Employee headMarketing = 
       new Employee("Michel","Head Marketing", 20000);

    Employee clerk1 = 
       new Employee("Laura","Marketing", 10000);
    Employee clerk2 = 
       new Employee("Bob","Marketing", 10000);

    Employee salesExecutive1 = 
       new Employee("Richard","Sales", 10000);
    Employee salesExecutive2 = 
       new Employee("Rob","Sales", 10000);

    CEO.add(headSales);
    CEO.add(headMarketing);

    headSales.add(salesExecutive1);
    headSales.add(salesExecutive2);

    headMarketing.add(clerk1);
    headMarketing.add(clerk2);

    //print all employees of the organization
    System.out.println(CEO); 

    for (Employee headEmployee : CEO.getSubordinates()) {
      System.out.println(headEmployee);

      for (Employee employee : headEmployee.getSubordinates()) {
        System.out.println(employee);
      }
    }		
  }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Verify the output.</p>

<pre>
<code>
Employee: [Name: John, Dept: CEO, Salary: $30000]
Employee: [Name: Robert, Dept: Head Sales, Salary: $20000]
Employee: [Name: Richard, Dept: Sales, Salary: $10000]
Employee: [Name: Rob, Dept: Sales, Salary: $10000]
Employee: [Name: Michel, Dept: Head Marketing, Salary: $20000]
Employee: [Name: Laura, Dept: Marketing, Salary: $10000]
Employee: [Name: Bob, Dept: Marketing, Salary: $10000]
</code>
</pre>     

        <hr/>

        <a name="decorator" id="decorator"></a>
        <h5>Decorator Pattern</h5>        
        <p>Decorator pattern allows a user to add new functionality to an 
           existing object without altering its structure. This type of design 
           pattern comes under structural pattern as this pattern acts as a 
           wrapper to existing class.</p>

        <p>This pattern creates a decorator class which wraps the original class
           and provides additional functionality keeping class methods signature
           intact.</p>

        <p>We are demonstrating the use of decorator pattern via following 
           example in which we will decorate a shape with some color without 
           alter shape class.</p>

        <h5>Implementation</h5>
        <p>We're going to create a Shape interface and concrete classes 
           implementing the Shape interface. We will then create an abstract 
           decorator class ShapeDecorator implementing the Shape interface and 
           having Shape object as its instance variable.</p>

        <h5>When to use</h5>        
        <ul>
          <li>Want the capabilities of inheritance with subclasses, but you need
              to add functionality at run time</li>
        </ul>
        
        <p>RedShapeDecorator is concrete class implementing ShapeDecorator.</p>

        <p>DecoratorPattern, our demo class will use RedShapeDecorator to 
           decorate Shape objects.</p>

        <img src="../assets/images/decoratorPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/decorator/Shape.java"
           target="_blank"> 
          Shape.java</a>
    
<pre>
<code>        
public interface Shape {
   void draw();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/decorator/Rectangle.java"
           target="_blank"> 
          Rectangle.java</a>
    
<pre>
<code>
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Shape: Rectangle");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/decorator/Circle.java"
           target="_blank"> 
          Circle.java</a>
    
<pre>
<code>        
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Shape: Circle");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create abstract decorator class implementing the Shape interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/decorator/ShapeDecorator.java"
           target="_blank"> 
          ShapeDecorator.java</a>
    
<pre>
<code>        
public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;

   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }

   public void draw(){
      decoratedShape.draw();
   }	
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create concrete decorator class extending the ShapeDecorator class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/decorator/RedShapeDecorator.java"
           target="_blank"> 
          RedShapeDecorator.java</a>
    
<pre>
<code>        
public class RedShapeDecorator extends ShapeDecorator {
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);		
   }

   @Override
   public void draw() {
      decoratedShape.draw();	       
      setRedBorder(decoratedShape);
   }

   private void setRedBorder(Shape decoratedShape){
      System.out.println("Border Color: Red");
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Use the RedShapeDecorator to decorate Shape objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/decorator/DecoratorPattern.java"
           target="_blank"> 
          DecoratorPattern.java</a>
    
<pre>
<code>        
public class DecoratorPattern {
 public static void main(String[] args) {

  Shape circle = new Circle();

  Shape redCircle = new RedShapeDecorator(new Circle());

  Shape redRectangle = new RedShapeDecorator(new Rectangle());
  System.out.println("Circle with normal border");
  circle.draw();

  System.out.println("\nCircle of red border");
  redCircle.draw();

  System.out.println("\nRectangle of red border");
  redRectangle.draw();
 }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Verify the output.</p>

<pre>
<code>        
Circle with normal border
Shape: Circle

Circle of red border
Shape: Circle
Border Color: Red

Rectangle of red border
Shape: Rectangle
Border Color: Red        
</code>
</pre>       

        <hr/>
        
        <a name="facade" id="facade"></a>
        <h5>Facade Pattern</h5>        
        <p>Facade pattern hides the complexities of the system and provides an             
           interface to the client using which the client can access the system. 
           This type of design pattern comes under structural pattern as this 
           pattern adds an interface to existing system to hide its 
           complexities.</p>

        <p>This pattern involves a single class which provides simplified 
           methods required by client and delegates calls to methods of existing
           system classes.</p>

        <h5>Implementation</h5>
        <p>We are going to create a Shape interface and concrete classes 
           implementing the Shape interface. A facade class ShapeMaker is 
           defined as a next step.</p>

        <h5>When to use</h5>        
        <ul>
          <li>To Create a simplified interface that performs many other actions
              behind the scenes</li>
        </ul>
        
        <p>ShapeMaker class uses the concrete classes to delegate user calls to 
           these classes. FacadePatternDemo, our demo class, will use ShapeMaker
           class to show the results.</p>

        <img src="../assets/images/facadePattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/facade/Shape.java"
           target="_blank"> 
          Shape.java</a>
    
<pre>
<code>        
public interface Shape {
   void draw();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/facade/Rectangle.java"
           target="_blank"> 
          Rectangle.java</a>
    
<pre>
<code>        
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Rectangle::draw()");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/facade/Square.java"
           target="_blank"> 
          Square.java</a>
    
<pre>
<code>        
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/facade/Circle.java"
           target="_blank"> 
          Circle.java</a>
    
<pre>
<code>        
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Circle::draw()");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create a facade class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/facade/ShapeMaker.java"
           target="_blank"> 
          ShapeMaker.java</a>
    
<pre>
<code>        
public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;

   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }

   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the facade to draw various types of shapes.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/facade/FacadePattern.java"
           target="_blank"> 
          FacadePattern.java</a>
    
<pre>
<code>        
public class FacadePattern {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();

      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();		
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Circle::draw()
Rectangle::draw()
Square::draw()        
</code>
</pre>        
        
        <hr/>

        <a name="flyweight" id="flyweight"></a>
        <h5>Flyweight Pattern</h5>
        <p>Flyweight pattern is primarily used to reduce the number of objects 
           created and to decrease memory footprint and increase performance. 
           This type of design pattern comes under structural pattern as this 
           pattern provides ways to decrease object count thus improving the 
           object structure of application.</p>

        <p>Flyweight pattern tries to reuse already existing similar kind 
           objects by storing them and creates new object when no matching 
           object is found. We will demonstrate this pattern by drawing 20 
           circles of different locations but we will create only 5 objects. 
           Only 5 colors are available so color property is used to check 
           already existing Circle objects.</p>

        <h5>Implementation</h5>
        <p>We are going to create a Shape interface and concrete class Circle 
           implementing the Shape interface. A factory class ShapeFactory is 
           defined as a next step.</p>

        <h5>When to use</h5>        
        <ul>
          <li>Need to create a large number of similar objects</li>
        </ul>
        
        <p>ShapeFactory has a HashMap of Circle having key as color of the 
           Circle object. Whenever a request comes to create a circle of 
           particular color to ShapeFactory, it checks the circle object in 
           its HashMap, if object of Circle found, that object is returned 
           otherwise a new object is created, stored in hashmap for future use, 
           and returned to client.</p>

        <p>FlyWeightPattern, our demo class, will use ShapeFactory to get a 
           Shape object. It will pass information (red / green / blue/ black / 
           white) to ShapeFactory to get the circle of desired color it 
           needs.</p>

        <img src="../assets/images/flyweightPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/flyweight/Shape.java"
           target="_blank"> 
          Shape.java</a>
    
<pre>
<code>        
public interface Shape {
   void draw();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete class implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/flyweight/Circle.java"
           target="_blank"> 
          Circle.java</a>
    
<pre>
<code>        
public class Circle implements Shape {
   private String color;
   private int x;
   private int y;
   private int radius;

   public Circle(String color){
      this.color = color;		
   }

   public void setX(int x) {
      this.x = x;
   }

   public void setY(int y) {
      this.y = y;
   }

   public void setRadius(int radius) {
      this.radius = radius;
   }

   @Override
   public void draw() {
      System.out.println("Circle: Draw() 
           [Color : " + color + ", 
                 x : " + x + ", 
                 y : " + y + ", 
            radius : " + radius);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create a factory to generate object of concrete class based on given 
        information.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/flyweight/ShapeFactory.java"
           target="_blank"> 
          ShapeFactory.java</a>
    
<pre>
<code>        
import java.util.HashMap;

public class ShapeFactory {

   // Uncomment the compiler directive line and
   // javac *.java will compile properly.
   // @SuppressWarnings("unchecked")
   private static final HashMap circleMap = new HashMap();

   public static Shape getCircle(String color) {
      Circle circle = (Circle)circleMap.get(color);

      if(circle == null) {
         circle = new Circle(color);
         circleMap.put(color, circle);
         System.out.println("Creating circle of color : " 
            + color);
      }
      return circle;
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the factory to get object of concrete class by passing an 
        information such as color.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/flyweight/FlyweightPattern.java"
           target="_blank"> 
          FlyweightPattern.java</a>
    
<pre>
<code>        
public class FlyweightPattern {
   private static final String colors[] = 
      { "Red", "Green", "Blue", "White", "Black" };
   public static void main(String[] args) {

      for(int i=0; i < 20; ++i) {
         Circle circle = 
            (Circle)ShapeFactory.getCircle(getRandomColor());
         circle.setX(getRandomX());
         circle.setY(getRandomY());
         circle.setRadius(100);
         circle.draw();
      }
   }
   private static String getRandomColor() {
      return colors[(int)(Math.random()*colors.length)];
   }
   private static int getRandomX() {
      return (int)(Math.random()*100 );
   }
   private static int getRandomY() {
      return (int)(Math.random()*100);
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Creating circle of color : Black
Circle: Draw() [Color : Black, x : 36, y :71, radius :100
Creating circle of color : Green
Circle: Draw() [Color : Green, x : 27, y :27, radius :100
Creating circle of color : White
Circle: Draw() [Color : White, x : 64, y :10, radius :100
Creating circle of color : Red
Circle: Draw() [Color : Red, x : 15, y :44, radius :100
Circle: Draw() [Color : Green, x : 19, y :10, radius :100
Circle: Draw() [Color : Green, x : 94, y :32, radius :100
Circle: Draw() [Color : White, x : 69, y :98, radius :100
Creating circle of color : Blue
Circle: Draw() [Color : Blue, x : 13, y :4, radius :100
Circle: Draw() [Color : Green, x : 21, y :21, radius :100
Circle: Draw() [Color : Blue, x : 55, y :86, radius :100
Circle: Draw() [Color : White, x : 90, y :70, radius :100
Circle: Draw() [Color : Green, x : 78, y :3, radius :100
Circle: Draw() [Color : Green, x : 64, y :89, radius :100
Circle: Draw() [Color : Blue, x : 3, y :91, radius :100
Circle: Draw() [Color : Blue, x : 62, y :82, radius :100
Circle: Draw() [Color : Green, x : 97, y :61, radius :100
Circle: Draw() [Color : Green, x : 86, y :12, radius :100
Circle: Draw() [Color : Green, x : 38, y :93, radius :100
Circle: Draw() [Color : Red, x : 76, y :82, radius :100
Circle: Draw() [Color : Blue, x : 95, y :82, radius :100
</code>
</pre>        
        
        <hr/>        

        <a name="proxy" id="proxy"></a>
        <h5>Proxy Pattern</h5>        
        <p>In proxy pattern, a class represents functionality of another class. 
            This type of design pattern comes under structural pattern.</p>

        <p>In proxy pattern, we create object having original object to 
            interface its functionality to outer world.</p>

        <h5>Implementation</h5>
        <p>We are going to create an Image interface and concrete classes 
           implementing the Image interface. ProxyImage is a a proxy class to 
           reduce memory footprint of RealImage object loading.</p>

        <h5>When to use</h5>
        <ul>
          <li>Provide a class which will limit access to another class</li>
          <li>Types of Proxies</li>
          
          <ul>
            <li>Remote proxy: They are responsible for representing the object 
                              located remotely. Talking to the real object might 
                              involve marshalling and unmarshalling of data and 
                              talking to the remote object. All that logic is 
                              encapsulated in these proxies and the client 
                              application need not worry about them.</li>
            <li>Virtual proxy: These proxies will provide some default and 
                               instant results if the real object is supposed 
                               to take some time to produce results. These 
                               proxies initiate the operation on real objects 
                               and provide a default result to the application. 
                               Once the real object is done, these proxies push 
                               the actual data to the client where it has 
                               provided dummy data earlier.</li>
            <li>Protection proxy: If an application does not have access to some 
                                  resource then such proxies will talk to the 
                                  objects in applications that have access to 
                                  that resource and then get the result 
                                  back.</li>
            <li>Smart Proxy: A smart proxy provides additional layer of security
                             by interposing specific actions when the object is 
                             accessed. An example can be to check if the real 
                             object is locked before it is accessed to ensure 
                             that no other object can change it.</li>
          </ul>
        </ul>
        
        <p>ProxyPatternDemo, our demo class, will use ProxyImage to get an Image
           object to load and display as it needs.</p>

        <img src="../assets/images/proxyPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/proxy/Image.java"
           target="_blank"> 
          Image.java</a>
    
<pre>
<code>        
public interface Image {
   void display();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/proxy/RealImage.java"
           target="_blank"> 
          RealImage.java</a>
    
<pre>
<code>        
public class RealImage implements Image {

   private String fileName;

   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }

   @Override
   public void display() {
      System.out.println("Displaying " + fileName);
   }

   private void loadFromDisk(String fileName){
      System.out.println("Loading " + fileName);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/proxy/ProxyImage.java"
           target="_blank"> 
          ProxyImage.java</a>
    
<pre>
<code>        
public class ProxyImage implements Image{

   private RealImage realImage;
   private String fileName;

   public ProxyImage(String fileName){
      this.fileName = fileName;
   }

   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Use the ProxyImage to get object of RealImage class when required.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/structural/proxy/ProxyPattern.java"
           target="_blank"> 
          ProxyPattern.java</a>
    
<pre>
<code>        
public class ProxyPattern {	
   public static void main(String[] args) {
      Image image = new ProxyImage("test_10mb.jpg");

      //image will be loaded from disk
      image.display(); 
      System.out.println("");
      
      //image will not be loaded from disk
      image.display(); 	
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
Loading test_10mb.jpg
Displaying test_10mb.jpg

Displaying test_10mb.jpg
</code>
</pre>        
        
        <hr/>

        <a name="behavioral" id="behavioral"></a>
        <h3>Behavioral Patterns</h3>

        <ul>
          <li><a href="#chain">Chain of responsibility</a>
                      :	Avoid coupling the sender of a request to its receiver 
                        by giving more than one object a chance to handle the 
                        request. Chain the receiving objects and pass the 
                        request along the chain until an object handles it.</li>
          <li><a href="#command">Command</a>
                      : Encapsulate a request as an object, thereby allowing for
                        the parameterization of clients with different requests,
                        and the queuing or logging of requests. It also allows 
                        for the support of undoable operations.</li>
          <li><a href="#interpreter">Interpreter</a>
                      :	Given a language, define a representation for its 
                        grammar along with an interpreter that uses the 
                        representation to interpret sentences in the 
                        language.</li>
          <li><a href="#iterator">Iterator</a>
                      : Provide a way to access the elements of an aggregate 
                        object sequentially without exposing its underlying 
                        representation.</li>
          <li><a href="#mediator">Mediator</a>
                      : Define an object that encapsulates how a set of objects 
                        interact. Mediator promotes loose coupling by keeping 
                        objects from referring to each other explicitly, and it 
                        allows their interaction to vary independently.</li>
          <li><a href="#memento">Memento</a>
                      : Without violating encapsulation, capture and externalize
                        an object's internal state allowing the object to be 
                        restored to this state later.</li>
          <li><a href="#observer">Observer/ Publish/ Subscribe</a>
                      : Define a one-to-many dependency between objects where a 
                        state change in one object results in all its dependents
                        being notified and updated automatically.</li>
          <li><a href="#state">State</a>
                      :	Allow an object to alter its behavior when its internal 
                        state changes. The object will appear to change its 
                        class.</li>
          <li><a href="#null">Null Object</a>
                      :	Avoid null references by providing a default 
                                object.</li>
          <li><a href="#strategy">Strategy</a>
                    :	Define a family of algorithms, encapsulate each one, and
                        make them interchangeable. Strategy lets the algorithm 
                        vary independently from clients that use it.</li>
          <li><a href="#template">Template Method</a>
                    :	Define the skeleton of an algorithm in an operation, 
                        deferring some steps to subclasses. Template method lets
                        subclasses redefine certain steps of an algorithm 
                        without changing the algorithm's structure.</li>
          <li><a href="#visitor">Visitor</a>
                  :	Represent an operation to be performed on the elements 
                        of an object structure. Visitor lets a new operation be 
                        defined without changing the classes of the elements on 
                        which it operates.</li>
        </ul>


<!---
Blackboard	Artificial intelligence pattern for combining disparate sources of data (see blackboard system)
Servant	Define common functionality for a group of classes.	
Specification	Recombinable business logic in a Boolean fashion.
--->

        
        <a name="chain" id="chain"></a>
        <h5>Chain of Responsibility Pattern</h5>        
        <p>As the name suggests, the chain of responsibility pattern creates a 
           chain of receiver objects for a request. This pattern decouples 
           sender and receiver of a request based on type of request. This 
           pattern comes under behavioral patterns.</p>

        <p>In this pattern, normally each receiver contains reference to another 
           receiver. If one object cannot handle the request then it passes the 
           same to the next receiver and so on.</p>

        <h5>Implementation</h5>
        <p>We have created an abstract class AbstractLogger with a level of 
           logging. Then we have created three types of loggers extending the 
           AbstractLogger. Each logger checks the level of message to its level 
           and print accordingly otherwise does not print and pass the message 
           to its next logger.</p>

        <h5>When to use</h5>       
        <ul>
          <li>To sends data to an object and if that object can't use it,
              to send it to any number of other objects that may be able to 
              use it</li>
        </ul>
        
        <img src="../assets/images/chainPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an abstract logger class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/chain/AbstractLogger.java"
           target="_blank"> 
          AbstractLogger.java</a>
    
<pre>
<code>
public abstract class AbstractLogger {
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;

   protected int level;

   //next element in chain or responsibility
   protected AbstractLogger nextLogger;

   public void setNextLogger(AbstractLogger nextLogger){
      this.nextLogger = nextLogger;
   }

   public void logMessage(int level, String message){
      if(this.level <= level){
         write(message);
      }
      if(nextLogger !=null){
         nextLogger.logMessage(level, message);
      }
   }
   abstract protected void write(String message);	
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes extending the logger.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/chain/ConsoleLogger.java"
           target="_blank"> 
          ConsoleLogger.java</a>
    
<pre>
<code>
public class ConsoleLogger extends AbstractLogger {
   public ConsoleLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {		
      System.out.println("Standard Console::Logger: " 
      + message);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/chain/ErrorLogger.java"
           target="_blank"> 
          ErrorLogger.java</a>
    
<pre>
<code>
public class ErrorLogger extends AbstractLogger {
   public ErrorLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {		
      System.out.println("Error Console::Logger: " 
            + message);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/chain/FileLogger.java"
           target="_blank"> 
          FileLogger.java</a>
    
<pre>
<code>
public class FileLogger extends AbstractLogger {

   public FileLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {		
      System.out.println("File::Logger: " 
            + message);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create different types of loggers. Assign them error levels and set next 
        logger in each logger. Next logger in each logger represents the part 
        of the chain.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/chain/ChainPattern.java"
           target="_blank"> 
          ChainPattern.java</a>
    
<pre>
<code>
public class ChainPattern {	
   private static AbstractLogger getChainOfLoggers(){
      AbstractLogger errorLogger = 
         new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = 
         new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = 
         new ConsoleLogger(AbstractLogger.INFO);

      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);

      return errorLogger;	
   }

   public static void main(String[] args) {
      AbstractLogger loggerChain = getChainOfLoggers();

      loggerChain.logMessage(AbstractLogger.INFO, 
         "This is information.");

      loggerChain.logMessage(AbstractLogger.DEBUG, 
         "This is debug level information.");

      loggerChain.logMessage(AbstractLogger.ERROR, 
         "This is error information.");
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
Standard Console::Logger: This is information.
File::Logger: This is debug level information.
Standard Console::Logger: This is debug level information.
Error Console::Logger: This is error information.
File::Logger: This is error information.
Standard Console::Logger: This is error information.      
</code>
</pre>

        <hr/>

        <a name="command" id="command"></a>
        <h5>Command Pattern</h5>
        <p>Command pattern is a data driven design pattern and falls under 
           behavioral pattern category. A request is wrapped under an object 
           as command and passed to invoker object. Invoker object looks for 
           the appropriate object which can handle this command and passes the 
           command to the corresponding object which executes the command.</p>

        <h5>Implementation</h5>
        <p>We have created an interface Order which is acting as a command. We 
           have created a Stock class which acts as a request. We have concrete 
           command classes BuyStock and SellStock implementing Order interface 
           which will do actual command processing. A class Broker is created 
           which acts as an invoker object. It can take and place orders.</p>

        <h5>When to use</h5>
        <ul>
          <li>Need to issue requests to objects without knowing anything about 
              the operation being requested or the receiver of the request.</li>
        </ul>
        
        <p>Broker object uses command pattern to identify which object will 
           execute which command based on the type of command. 
           CommandPattern, our demo class, will use Broker class to 
           demonstrate command pattern.</p>

        <img src="../assets/images/commandPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create a command interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/command/Order.java"
           target="_blank"> 
          Order.java</a>
    
<pre>
<code>
public interface Order {
   void execute();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create a request class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/command/Stock.java"
           target="_blank"> 
          Stock.java</a>
    
<pre>
<code>
public class Stock {	
   private String name = "ABC";
   private int quantity = 10;

   public void buy(){
      System.out.println("Stock [ Name: "+name+", "
              + "Quantity: " + quantity +" ] bought");
   }
   public void sell(){
      System.out.println("Stock [ Name: "+name+", "
              + "Quantity: " + quantity +" ] sold");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create concrete classes implementing the Order interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/command/BuyStock.java"
           target="_blank"> 
          BuyStock.java</a>
    
<pre>
<code>
public class BuyStock implements Order {
   private Stock abcStock;

   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.buy();
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/command/SellStock.java"
           target="_blank"> 
          SellStock.java</a>
    
<pre>
<code>
public class SellStock implements Order {
   private Stock abcStock;

   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.sell();
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create command invoker class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/command/Broker.java"
           target="_blank"> 
          Broker.java</a>
    
<pre>
<code>
import java.util.ArrayList;
import java.util.List;

   public class Broker {
   private List<Order> orderList = new ArrayList<Order>(); 

   public void takeOrder(Order order){
      orderList.add(order);		
   }

   public void placeOrders(){
   
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Use the Broker class to take and execute commands.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/command/CommandPattern.java"
           target="_blank"> 
          CommandPattern.java</a>
    
<pre>
<code>
public class CommandPattern {
   public static void main(String[] args) {
      Stock abcStock = new Stock();

      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);

      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);

      broker.placeOrders();
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Verify the output.</p>

<pre>
<code>
Stock [ Name: ABC, Quantity: 10 ] bought
Stock [ Name: ABC, Quantity: 10 ] sold
</code>
</pre>        
        
        <hr/>

        <a name="interpreter" id="interpreter"></a>
        <h5>Interpreter Pattern</h5>        
        <p>Interpreter pattern provides a way to evaluate language grammar or 
           expression. This type of pattern comes under behavioral pattern. This
           pattern involves implementing an expression interface which tells to 
           interpret a particular context. This pattern is used in SQL parsing, 
           symbol processing engine etc.</p>

        <h5>Implementation</h5>
        <p>We are going to create an interface Expression and concrete classes 
           implementing the Expression interface. A class TerminalExpression is 
           defined which acts as a main interpreter of context in question. 
           Other classes OrExpression, AndExpression are used to create 
           combinational expressions.</p>

        <p>InterpreterPattern, our demo class, will use Expression class to 
           create rules and demonstrate parsing of expressions.</p>

        <h5>When to use</h5>        
        <ul> 
          <li>With Java reflection techniques to convert one representation of 
              data into another</li>
        </ul>
        
        <img src="../assets/images/interpreterPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an expression interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/interpreter/Expression.java"
           target="_blank"> 
          Expression.java</a>
        
<pre>
<code>
public interface Expression {
   public boolean interpret(String context);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the above interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/interpreter/TerminalExpression.java"
           target="_blank"> 
          TerminalExpression.java</a>
    
<pre>
<code>
public class TerminalExpression implements Expression {
   private String data;

   public TerminalExpression(String data){
      this.data = data; 
   }

   @Override
   public boolean interpret(String context) {
   
      if(context.contains(data)){
         return true;
      }
      return false;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/interpreter/OrExpression.java"
           target="_blank"> 
          OrExpression.java</a>
    
<pre>
<code>
public class OrExpression implements Expression {	 
   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {		
      return expr1.interpret(context) || 
             expr2.interpret(context);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/interpreter/AndExpression.java"
           target="_blank"> 
          AndExpression.java</a>
    
<pre>
<code>
public class AndExpression implements Expression {	 
   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {		
      return expr1.interpret(context) && 
             expr2.interpret(context);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        InterpreterPattern uses Expression class to create rules and then 
        parse them.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/interpreter/InterpreterPattern.java"
           target="_blank"> 
          InterpreterPattern.java</a>
    
<pre>
<code>
public class InterpreterPattern {

   //Rule: Robert and John are male
   public static Expression getMaleExpression(){
      Expression robert = new TerminalExpression("Robert");
      Expression john = new TerminalExpression("John");
      return new OrExpression(robert, john);		
   }

   //Rule: Julie is a married women
   public static Expression getMarriedWomanExpression(){
      Expression julie = new TerminalExpression("Julie");
      Expression married = new TerminalExpression("Married");
      return new AndExpression(julie, married);		
   }

   public static void main(String[] args) {
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();

      System.out.println("John is male? " 
         + isMale.interpret("John"));
      System.out.println("Julie is a married women? " 
         + isMarriedWoman.interpret("Married Julie"));
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
John is male? true
Julie is a married women? true
</code>
</pre>

        <hr/>
        
        <a name="iterator" id="iterator"></a>
        <h5>Iterator Pattern</h5>
                
        <p>Iterator pattern is very commonly used design pattern in Java and 
            .Net programming environment. This pattern is used to get a way to 
            access the elements of a collection object in sequential manner 
            without any need to know its underlying representation.</p>

        <p>Iterator pattern falls under behavioral pattern category.</p>

        <h5>Implementation</h5>
        <p>We're going to create a Iterator interface which narrates navigation 
           method and a Container interface which returns the iterator. 
           Concrete classes implementing the Container interface will be 
           responsible to implement Iterator interface and use it</p>

        <h5>When to use</h5>        
        <ul>
          <li>Provide a uniform way to cycle through different collections.
              For example, if you have an Array, ArrayList, and HashTable of 
              objects you can pop out an iterator for each and treat them 
              the same </li>
        </ul>
        
        <p>IteratorPatternDemo, our demo class will use NamesRepository, a 
           concrete class implementation to print a Names stored as a 
           collection in NamesRepository.</p>

        <img src="../assets/images/iteratorPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create interfaces.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/iterator/Iterator.java"
           target="_blank"> 
          Iterator.java</a>
<pre>
<code>
public interface Iterator {
   public boolean hasNext();
   public Object next();
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/iterator/Container.java"
           target="_blank"> 
          Container.java</a>
    
<pre>
<code>
public interface Container {
   public Iterator getIterator();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete class implementing the Container interface. This class 
        has inner class NameIterator implementing the Iterator interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/iterator/NameRepository.java"
           target="_blank"> 
          NameRepository.java</a>
    
<pre>
<code>
public class NameRepository implements Container {
   public String names[] = 
      {"Robert" , "John" ,"Julie" , "Lora"};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {
      int index;

      @Override
      public boolean hasNext() {      
         if(index < names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {      
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }		
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br>
        Use the NameRepository to get iterator and print names.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/iterator/IteratorPattern.java"
           target="_blank"> 
          IteratorPattern.java</a>
    
<pre>
<code>
public class IteratorPattern {	
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      } 	
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
Name : Robert
Name : John
Name : Julie
Name : Lora        
</code>
</pre>        
        
        <hr/>

        <a name="mediator" id="mediator"></a>
        <h5>Mediator Pattern</h5>                
        <p>Mediator pattern is used to reduce communication complexity between 
           multiple objects or classes. This pattern provides a mediator class 
           which normally handles all the communications between different 
           classes and supports easy maintenance of the code by loose coupling. 
           Mediator pattern falls under behavioral pattern category.</p>

        <h5>Implementation</h5>
        <p>We are demonstrating mediator pattern by example of a chat room where
           multiple users can send message to chat room and it is the 
           responsibility of chat room to show the messages to all users. We 
           have created two classes ChatRoom and User. User objects will use 
           ChatRoom method to share their messages.</p>

        <h5>When to use</h5>        
        <ul>
          <li>To handle communication between related objects (colleagues)</li>
        </ul>
        
        <p>MediatorPattern, our demo class, will use User objects to show 
           communication between them.</p>

        <img src="../assets/images/mediatorPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create mediator class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/mediator/ChatRoom.java"
           target="_blank"> 
          ChatRoom.java</a>
    
<pre>
<code>        
import java.util.Date;

public class ChatRoom {
   public static void showMessage(User user, String message){
      System.out.println(new Date().toString() 
           + " [" + user.getName() + "] : " + message);
   }
}
</code>
</pre>
        
        <p><strong>Step 2</strong><br/>
        Create user class</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/mediator/User.java"
           target="_blank"> 
          User.java</a>
<pre>
<code>        
public class User {
   private String name;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

   public User(String name){
      this.name  = name;
   }

   public void sendMessage(String message){
      ChatRoom.showMessage(this,message);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Use the User object to show communications between them.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/mediator/MediatorPattern.java"
           target="_blank"> 
          MediatorPattern.java</a>
<pre>
<code>
public class MediatorPattern {
   public static void main(String[] args) {
      User robert = new User("Robert");
      User john = new User("John");

      robert.sendMessage("Hi! John!");
      john.sendMessage("Hello! Robert!");
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
Wed Jun 27 12:21:04 EDT 2018 [Robert] : Hi! John!
Wed Jun 27 12:21:04 EDT 2018 [John] : Hello! Robert!
</code>
</pre>   

        <hr/>

        <a name="memento" id="memento"></a>
        <h5>Memento Pattern</h5>                
        <p>Memento pattern is used to restore state of an object to a previous 
           state. Memento pattern falls under behavioral pattern category.</p>

        <h5>Implementation</h5>
        <p>Memento pattern uses three actor classes. Memento contains state of 
           an object to be restored. Originator creates and stores states in 
           Memento objects and Caretaker object is responsible to restore object
           state from Memento. We have created classes Memento, Originator and 
           CareTaker.</p>

        <h5>When to use</h5>        
        <ul>
          <li>A way to store previous states of an object easily</li>        
        </ul>    
            
        <p>MementoPatternDemo, our demo class, will use CareTaker and Originator
           objects to show restoration of object states.</p>

        <img src="../assets/images/mementoPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Memento class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/memento/Memento.java"
           target="_blank"> 
          Memento.java</a>
    
<pre>
<code>        
public class Memento {
   private String state;

   public Memento(String state){
      this.state = state;
   }

   public String getState(){
      return state;
   }	
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create Originator class</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/memento/Originator.java"
           target="_blank"> 
          Originator.java</a>
        
<pre>
<code>
public class Originator {
   private String state;

   public void setState(String state){
      this.state = state;
   }

   public String getState(){
      return state;
   }

   public Memento saveStateToMemento(){
      return new Memento(state);
   }

   public void getStateFromMemento(Memento memento){
      state = memento.getState();
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create CareTaker class</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/memento/CareTaker.java"
           target="_blank"> 
          CareTaker.java</a>
        
<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class CareTaker {
   private List<Memento> mementoList = new ArrayList<Memento>();

   public void add(Memento state){
      mementoList.add(state);
   }

   public Memento get(int index){
      return mementoList.get(index);
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use CareTaker and Originator objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/memento/MementoPattern.java"
           target="_blank"> 
          MementoPattern.java</a>
        
<pre>
<code>        
public class MementoPattern {
 public static void main(String[] args) {
   
  Originator originator = new Originator();
  CareTaker careTaker = new CareTaker();
      
  originator.setState("State #1");
  originator.setState("State #2");
  careTaker.add(originator.saveStateToMemento());
      
  originator.setState("State #3");
  careTaker.add(originator.saveStateToMemento());
      
  originator.setState("State #4");
  System.out.println("Current State: " 
                    + originator.getState());		
      
  originator.getStateFromMemento(careTaker.get(0));
  System.out.println("First saved State: " 
                    + originator.getState());
  originator.getStateFromMemento(careTaker.get(1));
  System.out.println("Second saved State: " 
                    + originator.getState());
 }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Current State: State #4
First saved State: State #2
Second saved State: State #3
</code>
</pre>
        
        <hr/>        

        <a name="observer" id="observer"></a>
        <h5>Observer Pattern</h5>                
        <p>Observer pattern is used when there is one-to-many relationship 
           between objects such as if one object is modified, its dependent 
           objects are to be notified automatically. Observer pattern falls 
           under behavioral pattern category.</p>

        <h5>Implementation</h5>
        <p>Observer pattern uses three actor classes. Subject, Observer and 
           Client. Subject is an object having methods to attach and detach 
           observers to a client object. We have created an abstract class 
           Observer and a concrete class Subject that is extending class 
           Observer.</p>

        <h5>When to use</h5>    
        <ul>
          <li>Need many other objects to receive an update when another 
              object changes</li>
        </ul>
    
        <p>ObserverPattern, our demo class, will use Subject and concrete 
           class object to show observer pattern in action.</p>

        <img src="../assets/images/observerPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Subject class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/observer/Subject.java"
           target="_blank"> 
          Subject.java</a>
        
<pre>
<code>
import java.util.ArrayList;
import java.util.List;

public class Subject {
	
   private List<Observer> observers = 
       new ArrayList<Observer>();
   private int state;

   public int getState() {
      return state;
   }

   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }

   public void attach(Observer observer){
      observers.add(observer);		
   }

   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   } 	
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create Observer class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/observer/Observer.java"
           target="_blank"> 
          Observer.java</a>
        
<pre>
<code>
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create concrete observer classes</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/observer/BinaryObserver.java"
           target="_blank"> 
          BinaryObserver.java</a>
        
<pre>
<code>        
public class BinaryObserver extends Observer{
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
      System.out.println( "Binary String: " 
         + Integer.toBinaryString( subject.getState() ) ); 
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/observer/OctalObserver.java"
           target="_blank"> 
          OctalObserver.java</a>
        
<pre>
<code>        
public class OctalObserver extends Observer{

   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
     System.out.println( "Octal String: " 
        + Integer.toOctalString( subject.getState() ) ); 
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/observer/HexaObserver.java"
           target="_blank"> 
          HexaObserver.java</a>
        
<pre>
<code>        
public class HexaObserver extends Observer{

   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
     System.out.println( "Hex String: " 
     + Integer.toHexString(subject.getState()).toUpperCase()); 
   }
}
</code>
</pre>
        <p><strong>Step 4</strong><br/>
        Use Subject and concrete observer objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/observer/ObserverPattern.java"
           target="_blank"> 
          ObserverPattern.java</a>
        
<pre>
<code>        
public class ObserverPattern {
   public static void main(String[] args) {
      Subject subject = new Subject();

      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);

      System.out.println("First state change: 15");	
      subject.setState(15);
      System.out.println("Second state change: 10");	
      subject.setState(10);
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
</code>
</pre>

        <hr/>
        
        <a name="state" id="state"></a>
        <h5>State Pattern</h5>               
        <p>In State pattern a class behavior changes based on its state. This 
            type of design pattern comes under behavior pattern.</p>

        <p>In State pattern, we create objects which represent various states 
           and a context object whose behavior varies as its state object 
           changes.</p>

        <h5>Implementation</h5>
        <p>We are going to create a State interface defining an action and 
           concrete state classes implementing the State interface. Context 
           is a class which carries a State.</p>

        <h5>When to use</h5>
        <ul>
            <li>To alter an objects behavior when its internal state changes.  
                The object will appear to change its class.</li>
        </ul>

        <p>StatePattern, our demo class, will use Context and state objects 
           to demonstrate change in Context behavior based on type of state it 
           is in.</p>

        <img src="../assets/images/statePattern.png" alt=""/>

        <p><strong>Step 1</strong></br>
        Create an interface.</p>
    
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/state/State.java"
           target="_blank"> 
          State.java</a>
        
<pre>
<code>        
public interface State {
   public void doAction(Context context);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/state/StartState.java"
           target="_blank"> 
          StartState.java</a>
        
<pre>
<code>
public class StartState implements State {

   public void doAction(Context context) {
      System.out.println("Player is in start state");
      context.setState(this);	
   }

   public String toString(){
      return "Start State";
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/state/StopState.java"
           target="_blank"> 
          StopState.java</a>
<pre>
<code>        
public class StopState implements State {

   public void doAction(Context context) {
      System.out.println("Player is in stop state");
      context.setState(this);	
   }

   public String toString(){
      return "Stop State";
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create Context Class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/state/Context.java"
           target="_blank"> 
          Context.java</a>
        
<pre>
<code>        
public class Context {
   private State state;

   public Context(){
      state = null;
   }

   public void setState(State state){
      this.state = state;		
   }

   public State getState(){
      return state;
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the Context to see change in behaviour when State changes.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/state/StatePattern.java"
           target="_blank"> 
          StatePattern.java</a>
        
<pre>
<code>        
public class StatePattern {
   public static void main(String[] args) {
      Context context = new Context();

      StartState startState = new StartState();
      startState.doAction(context);

      System.out.println(context.getState().toString());

      StopState stopState = new StopState();
      stopState.doAction(context);

      System.out.println(context.getState().toString());
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Player is in start state
Start State
Player is in stop state
Stop State
</code>
</pre>

        <hr/>
        
        <a name="null" id="null"></a>
        <h5>Null Object Pattern</h5>        
        <p>In Null Object pattern, a null object replaces check of NULL object 
           instance. Instead of putting if check for a null value, Null Object 
           reflects a do nothing relationship. Such Null object can also be 
           used to provide default behavior in case data is not available.</p>

        <p>In Null Object pattern, we create an abstract class specifying 
           various operations to be done, concrete classes extending this 
           class and a null object class providing do nothing implementation 
           of this class and will be used seemlessly where we need to check 
           null value.</p>

        <h5>Implementation</h5>
        <p>We are going to create a AbstractCustomer abstract class defining 
           operations. Here the name of the customer and concrete classes 
           extending the AbstractCustomer class. A factory class CustomerFactory
           is created to return either RealCustomer or NullCustomer objects 
           based on the name of customer passed to it.</p>

        <h5>When to use</h5>        
        <ul>
          <li>An object requires a collaborator. The Null Object pattern does 
              not introduce this collaboration--it makes use of a collaboration 
              that already exists</li>
          <li>Some collaborator instances should do nothing</li>
          <li>You want to abstract the handling of null away from the client</li>
        </ul>
        
        <p>NullPatternDemo, our demo class, will use CustomerFactory to 
           demonstrate the use of Null Object pattern.</p>
    
        <img src="../assets/images/nullObjectPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an abstract class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/nullobject/AbstractCustomer.java"
           target="_blank"> 
          AbstractCustomer.java</a>
        
<pre>
<code>        
public abstract class AbstractCustomer {
   protected String name;
   public abstract boolean isNil();
   public abstract String getName();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes extending the above class.</p>

        See <span class="fa fa-file-code-o"></span> RealCustomer.java
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/state/StatePattern.java"
           target="_blank"> 
          StatePattern.java</a>
        
<pre>
<code>        
public class RealCustomer extends AbstractCustomer {
   public RealCustomer(String name) {
      this.name = name;		
   }
   
   @Override
   public String getName() {
      return name;
   }
   
   @Override
   public boolean isNil() {
      return false;
   }
}
</code>
</pre>

        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/nullobject/NullCustomer.java"
           target="_blank"> 
          NullCustomer.java</a>
        
<pre>
<code>        
public class NullCustomer extends AbstractCustomer {
   @Override
   public String getName() {
      return "Not Available in Customer Database";
   }

   @Override
   public boolean isNil() {
      return true;
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create CustomerFactory Class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/nullobject/CustomerFactory.java"
           target="_blank"> 
          CustomerFactory.java</a>
        
<pre>
<code>        
public class CustomerFactory {	
   public static final String[] names = {"Rob", "Joe", "Julie"};

   public static AbstractCustomer getCustomer(String name){   
      for (int i = 0; i < names.length; i++) {
         if (names[i].equalsIgnoreCase(name)){
            return new RealCustomer(name);
         }
      }
      return new NullCustomer();
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the CustomerFactory to get either RealCustomer or NullCustomer 
        objects based on the name of customer passed to it.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/nullobject/NullPattern.java"
           target="_blank"> 
          NullPattern.java</a>
        
<pre>
<code>        
public class NullPattern {
   public static void main(String[] args) {
      AbstractCustomer customer1 = 
                       CustomerFactory.getCustomer("Rob");
      AbstractCustomer customer2 = 
                       CustomerFactory.getCustomer("Bob");
      AbstractCustomer customer3 = 
                       CustomerFactory.getCustomer("Julie");
      AbstractCustomer customer4 = 
                       CustomerFactory.getCustomer("Laura");

      System.out.println("Customers");
      System.out.println(customer1.getName());
      System.out.println(customer2.getName());
      System.out.println(customer3.getName());
      System.out.println(customer4.getName());
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Customers
Rob
Not Available in Customer Database
Julie
Not Available in Customer Database        
</code>
</pre>        
        
        <hr/>

        <a name="strategy" id="strategy"></a>
        <h5>Strategy Pattern</h5>
        
        <p>In Strategy pattern, a class behavior or its algorithm can be changed
           at run time. This type of design pattern comes under behavior 
           pattern.</p>

        <p>In Strategy pattern, we create objects which represent various 
           strategies and a context object whose behavior varies as per its 
           strategy object. The strategy object changes the executing algorithm 
           of the context object.</p>

        <h5>Implementation</h5>
        <p>We are going to create a Strategy interface defining an action and 
           concrete strategy classes implementing the Strategy interface. 
           Context is a class which uses a Strategy.</p>

        <h5>When to use</h5>
        <ul>
            <li>To define a class that will have one behavior that is similar 
                to other behaviors in a list</li>
            <li>To use one of several behaviors dynamically</li>
            <li>To reduce long lists of conditions and avoid duplicate code</li>
            <li>To keep class change form forcing other class changes</li>
            <li>To hide complicated/secret code form the user</li>            
        </ul>

        <p>StrategyPatternDemo, our demo class, will use Context and strategy 
           objects to demonstrate change in Context behavior based on strategy 
           it deploys or uses.</p>

        <img src="../assets/images/strategyPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create an interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/strategy/Strategy.java"
           target="_blank"> 
          Strategy.java</a>
<pre>
<code>        
public interface Strategy {
   public int doOperation(int num1, int num2);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes implementing the same interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/strategy/OperationAdd.java"
           target="_blank"> 
          OperationAdd.java</a>
        
<pre>
<code>        
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/strategy/OperationSubstract.java"
           target="_blank"> 
          OperationSubtract.java</a>
        
<pre>
<code>        
public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/strategy/OperationMultiply.java"
           target="_blank"> 
          OperationMultiply.java</a>
        
<pre>
<code>        
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create Context Class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/strategy/Context.java"
           target="_blank"> 
          Context.java</a>
        
<pre>
<code>        
public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;
   }

   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the Context to see change in behaviour when it changes its 
        Strategy.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/strategy/StrategyPattern.java"
           target="_blank"> 
          StrategyPattern.java</a>
        
<pre>
<code>        
public class StrategyPattern {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());		
      System.out.println("10 + 5 = " 
         + context.executeStrategy(10, 5));

      context = new Context(new OperationSubstract());		
      System.out.println("10 - 5 = " 
         + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());		
      System.out.println("10 * 5 = " 
         + context.executeStrategy(10, 5));
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50        
</code>
</pre>   

        <hr/>

        <a name="template" id="template"></a>
        <h5>Template Method Pattern</h5>
        
        <p>In Template Method pattern, an abstract class exposes defined 
           way(s)/template(s) to execute its methods. Its subclasses can 
           override the method implementation as per need but the invocation 
           is to be in the same way as defined by an abstract class. This 
           pattern comes under behavior pattern category.</p>

        <h5>Implementation</h5>
        <p>We are going to create a Game abstract class defining operations with
           a template method set to be final so that it cannot be overridden. 
           Cricket and Football are concrete classes that extend Game and 
           override its methods.</p>

        <h5>When to use</h5>        
        <ul>
          <li>To create a group of subclasses that have to execute a 
              similar group of methods</li>
        </ul>
                
        <p>TemplatePatternDemo, our demo class, will use Game to demonstrate 
           use of template pattern.</p>

        <img src="../assets/images/templatePattern.png" alt=""/>

        <p><strong>Step 1</strong></br>
        Create an abstract class with a template method being final.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/template/Game.java"
           target="_blank"> 
          Game.java</a>

        
<pre>
<code>
public abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();

   //template method
   public final void play(){

      //initialize the game
      initialize();

      //start game
      startPlay();

      //end game
      endPlay();
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes extending the above class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/template/Cricket.java"
           target="_blank"> 
          Cricket.java</a>

<pre>
<code>
public class Cricket extends Game {

   @Override
   void endPlay() {
      System.out.println("Cricket Game Finished!");
   }

   @Override
   void initialize() {
      System.out.println("Cricket Game Initialized! 
           Start playing.");
   }

   @Override
   void startPlay() {
      System.out.println("Cricket Game Started. 
           Enjoy the game!");
   }
}
</code>
</pre>
  
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/template/Football.java"
           target="_blank"> 
          Football.java</a>
        
<pre>
<code>
public class Football extends Game {

   @Override
   void endPlay() {
      System.out.println("Football Game Finished!");
   }

   @Override
   void initialize() {
      System.out.println("Football Game Initialized! "
        + "Start playing.");
   }

   @Override
   void startPlay() {
      System.out.println("Football Game Started. " 
        + "Enjoy the game!");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Use the Game's template method play() to demonstrate a defined way of 
        playing game.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/template/TemplatePattern.java"
           target="_blank"> 
          TemplatePattern.java</a>

<pre>
<code>
public class TemplatePatternDemo {
   public static void main(String[] args) {

      Game game = new Cricket();
      game.play();
      System.out.println();
      game = new Football();
      game.play();		
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
Cricket Game Initialized! Start playing.
Cricket Game Started. Enjoy the game!
Cricket Game Finished!

Football Game Initialized! Start playing.
Football Game Started. Enjoy the game!
Football Game Finished!        
</code>
</pre>

        <hr/>
        
        <a name="visitor" id="visitor"></a>
        <h5>Visitor Pattern</h5>
        
        <p>In Visitor pattern, we use a visitor class which changes the 
           executing algorithm of an element class. By this way, execution 
           algorithm of element can vary as and when visitor varies. This 
           pattern comes under behavior pattern category. As per the pattern, 
           element object has to accept the visitor object so that visitor 
           object handles the operation on the element object.</p>

        <h5>Implementation</h5>
        <p>We are going to create a ComputerPart interface defining accept 
           opearation. Keyboard, Mouse, Monitor and Computer are concrete 
           classes implementing ComputerPart interface. We will define another 
           interface ComputerPartVisitor which will define a visitor class 
           operations. Computer uses concrete visitor to do corresponding 
           action.</p>

        <h5>When to use</h5>
        <ul>
            <li>To add methods to classes of different types without much 
                altering to those classes</li>
        </ul>   
        
        <p>VisitorPatternDemo, our demo class, will use Computer and 
           ComputerPartVisitor classes to demonstrate use of visitor 
           pattern.</p>

        <img src="../assets/images/visitorPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Define an interface to represent element.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/ComputerPart.java"
           target="_blank"> 
          ComputerPart.java</a>

<pre>
<code>        
public interface ComputerPart {
   public void accept(ComputerPartVisitor computerPartVisitor);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete classes extending the above class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/Keyboard.java"
           target="_blank"> 
          Keyboard.java</a>

<pre>
<code>        
public class Keyboard implements ComputerPart {

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/Monitor.java"
           target="_blank"> 
          Monitor.java</a>

<pre>
<code>        
public class Monitor implements ComputerPart {
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/Mouse.java"
           target="_blank"> 
          Mouse.java</a>

<pre>
<code>        
public class Mouse implements ComputerPart {
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/Computer.java"
           target="_blank"> 
          Computer.java</a>

<pre>
<code>        
public class Computer implements ComputerPart {	
   ComputerPart[] parts;

   public Computer(){
      parts = new ComputerPart[] {new Mouse(), 
                                  new Keyboard(), 
                                  new Monitor()};		
   } 

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      for (int i = 0; i < parts.length; i++) {
         parts[i].accept(computerPartVisitor);
      }
      computerPartVisitor.visit(this);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Define an interface to represent visitor.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/ComputerPartVisitor.java"
           target="_blank"> 
          ComputerPartVisitor.java</a>

<pre>
<code>        
public interface ComputerPartVisitor {
  public void visit(Computer computer);
  public void visit(Mouse mouse);
  public void visit(Keyboard keyboard);
  public void visit(Monitor monitor);
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create concrete visitor implementing the above class.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/ComputerPartDisplayVisitor.java"
           target="_blank"> 
          ComputerPartDisplayVisitor.java</a>

<pre>
<code>        
public class ComputerPartDisplayVisitor 
                implements ComputerPartVisitor {
   @Override
   public void visit(Computer computer) {
      System.out.println("Displaying Computer.");
   }

   @Override
   public void visit(Mouse mouse) {
      System.out.println("Displaying Mouse.");
   }

   @Override
   public void visit(Keyboard keyboard) {
      System.out.println("Displaying Keyboard.");
   }

   @Override
   public void visit(Monitor monitor) {
      System.out.println("Displaying Monitor.");
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Use the ComputerPartDisplayVisitor to display parts of Computer.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/behavioral/visitor/VisitorPattern.java"
           target="_blank"> 
          VisitorPattern.java</a>

<pre>
<code>        
public class VisitorPattern {
   public static void main(String[] args) {
      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Verify the output.</p>

<pre>
<code>
Displaying Mouse.
Displaying Keyboard.
Displaying Monitor.
Displaying Computer.        
</code>
</pre>        
        
        <hr/>
        
        <a name="j2ee" id="j2ee"></a>
        <h3>Java Platform Enterprise Edition Patterns</h3>

        <ul>
          <li><a href="#mvc">Model View Controller (MVC)</a> :	 
                         divides an application into three interconnected parts.
                         This is done to separate internal representations of 
                         information from the ways information is presented to 
                         and accepted from the user. The MVC design pattern 
                         decouples these major components allowing for 
                         efficient code reuse and parallel development.</li>        
          <li><a href="#business">Business Delegate Pattern</a> : 
                         directing to reduce the coupling in between business 
                         services and the connected presentation-tier, and to 
                         hide the implementation details of services 
                         (including lookup and accessibility of EJB 
                         architecture. Business delegates acts as an adaptor to 
                         invoke business objects from the presentation 
                         tier.</li>
          <li><a href="#compositeentity">Composite Entity Pattern</a> : 
                         used to model, represent, and manage a set of 
                         interrelated persistent objects rather than 
                         representing them as individual fine-grained entity 
                         beans, and also a composite entity bean represents a 
                         graph of objects.</li>
          <li><a href="#data">Data Access Object Pattern</a> : 
                        used to separate low level data accessing API or 
                        operations from high level business services.</li>
          <li><a href="#front">Front Controller Pattern</a> : 
                        "a controller that handles all requests for a website", 
                        which is a useful structure for web application 
                        developers to achieve the flexibility and reuse without 
                        code redundancy.</li>
          <li><a href="#intercepting">Intercepting Filter Pattern</a> : 
                        Creates pluggable filters to process common services in 
                        a standard manner without requiring changes to core 
                        request processing code. The filters intercept incoming 
                        requests and outgoing responses, allowing preprocessing 
                        and post-processing, and these filters can be added or 
                        removed unobstrusively without changing existing code. 
                        This pattern applies reusable processing transparently 
                        before and after the actual request execution by the 
                        front and page controllers.</li>
          <li><a href="#service">Service Locator Pattern</a> : 
                        Encapsulate the processes involved in obtaining a 
                        service with a strong abstraction layer. This pattern 
                        uses a central registry known as the "service locator", 
                        which on request returns the information necessary to 
                        perform a certain task.</li>
          <li><a href="#transfer">Transfer Object Pattern</a> : 
                        an object that carries data between processes.</li>
        </ul>
        
        
        <a name="mvc" id="mvc"></a>
        <h5>Model View Controller (MVC)</h5>          
        <p>MVC Pattern stands for Model-View-Controller Pattern. This pattern 
           is used to separate application's concerns.</p>

        <ul>
          <li>Model - Model represents an object or JAVA POJO carrying data. It 
                      can also have logic to update controller if its data 
                      changes.</li>
          <li>View - View represents the visualization of the data that model 
                     contains.</li>
          <li>Controller - Controller acts on both model and view. It controls 
                           the data flow into model object and updates the view 
                           whenever data changes. It keeps view and model 
                           separate.</li>
        </ul>

        <h5>Implementation</h5>
        <p>We are going to create a Student object acting as a model. 
           StudentView will be a view class which can print student details on 
           console and StudentController is the controller class responsible to 
           store data in Student object and update view StudentView 
           accordingly.</p>

        <h5>When to use</h5>
        <ul>
          <li>To divide an application into three interconnected parts</li>
        </ul>    

        <p>MVCPatternDemo, our demo class, will use StudentController to 
           demonstrate use of MVC pattern.</p>

        <img src="../assets/images/mvcPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Model.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/mvc/Student.java"
           target="_blank"> 
          Student.java</a>
        
<pre>
<code>
public class Student {
   private String rollNo;
   private String name;
   
   public String getRollNo() {
      return rollNo;
   }
   
   public void setRollNo(String rollNo) {
      this.rollNo = rollNo;
   }
   
   public String getName() {
      return name;
   }
   
   public void setName(String name) {
      this.name = name;
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create View.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/mvc/StudentView.java"
           target="_blank"> 
          StudentView.java</a>
        
<pre>
<code>
public class StudentView {
   public void printStudentDetails(String studentName, 
                                   String studentRollNo){
      System.out.println("Student: ");
      System.out.println("Name: " + studentName);
      System.out.println("Roll No: " + studentRollNo);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create Controller.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/mvc/StudentController.java"
           target="_blank"> 
          StudentController.java</a>
        
<pre>
<code>
public class StudentController {
   private Student model;
   private StudentView view;

   public StudentController(Student model, 
                            StudentView view){
      this.model = model;
      this.view = view;
   }

   public void setStudentName(String name){
      model.setName(name);		
   }

   public String getStudentName(){
      return model.getName();		
   }

   public void setStudentRollNo(String rollNo){
      model.setRollNo(rollNo);		
   }

   public String getStudentRollNo(){
      return model.getRollNo();		
   }

   public void updateView(){				
      view.printStudentDetails(model.getName(), 
                               model.getRollNo());
   }	
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the StudentController methods to demonstrate MVC design pattern 
        usage.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/mvc/MVCPattern.java"
           target="_blank"> 
          MVCPattern.java</a>
        
<pre>
<code>
public class MVCPatternDemo {
   public static void main(String[] args) {
      //fetch student record based on his roll no 
      //from the database
      Student model  = retriveStudentFromDatabase();

      //Create a view : to write student details on console
      StudentView view = new StudentView();

      StudentController controller = new 
                        StudentController(model, view);

      controller.updateView();

      //update model data
      controller.setStudentName("John");

      controller.updateView();
   }

   private static Student retriveStudentFromDatabase(){
      Student student = new Student();
      student.setName("Robert");
      student.setRollNo("10");
      return student;
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Student: 
Name: Robert
Roll No: 10
Student: 
Name: John
Roll No: 10          
</code>
</pre>          
          
          <hr/>
          
          <a name="business" id="business"></a>
          <h5>Business Delegate Pattern</h5>
          
        <p>Business Delegate Pattern is used to decouple presentation tier and 
           business tier. It is basically use to reduce communication or remote 
           lookup functionality to business tier code in presentation tier code.
           In business tier we have following entities.</p>

        <ul>    
          <li>Client - Presentation tier code may be JSP, servlet or UI java 
                       code.</li>
          <li>Business Delegate - A single entry point class for client entities
                                  to provide access to Business Service 
                                  methods.</li>
          <li>LookUp Service - Lookup service object is responsible to get 
                               relative business implementation and provide 
                               business object access to business delegate 
                               object.</li>
          <li>Business Service - Business Service interface. Concrete classes 
                                 implement this business service to provide 
                                 actual business implementation logic.</li>
        </ul>

        <h5>Implementation</h5>
        <p>We are going to create a Client, BusinessDelegate, BusinessService, 
           LookUpService, JMSService and EJBService representing various 
           entities of Business Delegate patterns.</p>

        <h5>When to use</h5>        
        <ul>
          <li>To reduce coupling between presentation-tier clients and business 
              services. The Business Delegate hides the underlying 
              implementation details of the business service, such as lookup 
              and access details of the EJB architecture.</li>
        </ul>
        
        <p>BusinessDelegatePattern, our demo class, will use 
           BusinessDelegate and Client to demonstrate use of Business Delegate 
           pattern.</p>

        <img src="../assets/images/businessPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create BusinessService Interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/BusinessService.java"
           target="_blank"> 
          BusinessService.java</a>
        
<pre>
<code>
public interface BusinessService {
   public void doProcessing();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete Service classes.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/EJBService.java"
           target="_blank"> 
          EJBService.java</a>
        
<pre>
<code>        
public class EJBService implements BusinessService {
   @Override
   public void doProcessing() {
      System.out.println("Processing task by 
                invoking EJB Service");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/JMSService.java"
           target="_blank"> 
          JMSService.java</a>
        
<pre>
<code>
public class JMSService implements BusinessService {
   @Override
   public void doProcessing() {
      System.out.println("Processing task by 
                invoking JMS Service");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create Business Lookup Service.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/BusinessLookUp.java"
           target="_blank"> 
          BusinessLookUp.java</a>
        
<pre>
<code>
public class BusinessLookUp {
 public BusinessService getBusinessService(String serviceType){   
    if(serviceType.equalsIgnoreCase("EJB")){
       return new EJBService();
    }
    else {
       return new JMSService();
    }
 }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create Business Delegate.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/BusinessDelegate.java"
           target="_blank"> 
          BusinessDelegate.java</a>
        
<pre>
<code>        
public class BusinessDelegate {
   private BusinessLookUp lookupService = new BusinessLookUp();
   private BusinessService businessService;
   private String serviceType;

   public void setServiceType(String serviceType){
      this.serviceType = serviceType;
   }

   public void doTask(){
      businessService = lookupService.getBusinessService
                        (serviceType);
      businessService.doProcessing();		
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Create Client.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/Client.java"
           target="_blank"> 
          Client.java</a>
        
<pre>
<code>
public class Client {	
   BusinessDelegate businessService;

   public Client(BusinessDelegate businessService){
      this.businessService  = businessService;
   }

   public void doTask(){		
      businessService.doTask();
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Use BusinessDelegate and Client classes to demonstrate Business 
        Delegate pattern.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/businessdelegate/BusinessDelegatePattern.java"
           target="_blank"> 
          BusinessDelegatePattern.java</a>
        
<pre>
<code>        
public class BusinessDelegatePattern {	
   public static void main(String[] args) {
      BusinessDelegate businessDelegate = 
                   new BusinessDelegate();
      businessDelegate.setServiceType("EJB");

      Client client = new Client(businessDelegate);
      client.doTask();

      businessDelegate.setServiceType("JMS");
      client.doTask();
   }
}
</code>
</pre>

        <p><strong>Step 7</strong><br/>
        Verify the output.</p>

<pre>
<code>
Processing task by invoking EJB Service
Processing task by invoking JMS Service          
</code>
</pre>          

        <hr/>          

        <a name="compositeentity" id="compositeentity"></a>
        <h5>Composite Entity Pattern</h5>        
        <p>Composite Entity pattern is used in EJB persistence mechanism. A 
           Composite entity is an EJB entity bean which represents a graph of 
           objects. When a composite entity is updated, internally dependent 
           objects beans get updated automatically as being managed by EJB 
           entity bean. Following are the participants in Composite Entity 
           Bean.</p>

        <ul>
          <li>Composite Entity - It is primary entity bean. It can be coarse 
              grained or can contain a coarse grained object to be used for 
              persistence purpose.</li>
          <li>Coarse-Grained Object - This object contains dependent objects. It
              has its own life cycle and also manages life cycle of dependent 
              objects.</li>
          <li>Dependent Object - Dependent object is an object which depends on 
              coarse grained object for its persistence lifecycle.</li>
          <li>Strategies - Strategies represents how to implement a Composite 
              Entity.</li>
        </ul>

        <h5>Implementation</h5>
        <p>We are going to create CompositeEntity object acting as 
           CompositeEntity. CoarseGrainedObject will be a class which contains 
           dependent objects. CompositeEntityPatternDemo, our demo class will 
           use Client class to demonstrate use of Composite Entity pattern.</p>

        <h5>When to use</h5>
        <ul>
          <li>To model, represent, and manage a set of interrelated persistent 
              objects rather than representing them as individual fine-grained 
              entity beans. A Composite Entity bean represents a graph of 
              objects.</li>
        </ul>
        
        <img src="../assets/images/compositeEntityPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Dependent Objects.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/compositeentity/DependentObject1.java"
           target="_blank"> 
          DependentObject1.java</a>
        
<pre>
<code>
public class DependentObject1 {	
   private String data;

   public void setData(String data){
      this.data = data; 
   } 

   public String getData(){
      return data;
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/compositeentity/DependentObject2.java"
           target="_blank"> 
          DependentObject2.java</a>
        
<pre>
<code>
public class DependentObject2 {	
   private String data;

   public void setData(String data){
      this.data = data; 
   } 

   public String getData(){
      return data;
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create Coarse Grained Object.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/compositeentity/CoarseGrainedObject.java"
           target="_blank"> 
          CoarseGrainedObject.java</a>
        
<pre>
<code>
public class CoarseGrainedObject {
   DependentObject1 do1 = new DependentObject1();
   DependentObject2 do2 = new DependentObject2();

   public void setData(String data1, String data2){
      do1.setData(data1);
      do2.setData(data2);
   }

   public String[] getData(){
      return new String[] {do1.getData(),do2.getData()};
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create Composite Entity.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/compositeentity/CompositeEntity.java"
           target="_blank"> 
          CompositeEntity.java</a>
        
<pre>
<code>
public class CompositeEntity {
   private CoarseGrainedObject cgo = new CoarseGrainedObject();

   public void setData(String data1, String data2){
      cgo.setData(data1, data2);
   }

   public String[] getData(){
      return cgo.getData();
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create Client class to use Composite Entity.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/compositeentity/Client.java"
           target="_blank"> 
          Client.java</a>
        
<pre>
<code>
public class Client {
   private CompositeEntity compositeEntity = 
                       new CompositeEntity();

   public void printData(){   
      for (int i = 0; 
               i < compositeEntity.getData().length; 
               i++) {
         System.out.println("Data: " 
                + compositeEntity.getData()[i]);
      }
   }

   public void setData(String data1, String data2){
      compositeEntity.setData(data1, data2);
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Use the Client to demonstrate Composite Entity design pattern usage.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/compositeentity/CompositeEntityPattern.java"
           target="_blank"> 
          CompositeEntityPattern.java</a>
        
<pre>
<code>
public class CompositeEntityPattern {
   public static void main(String[] args) {   
       Client client = new Client();
       client.setData("Test", "Data");
       client.printData();
       client.setData("Second Test", "Data1");
       client.printData();
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Verify the output.</p>

<pre>
<code>
Data: Test
Data: Data
Data: Second Test
Data: Data1        
</code>
</pre>        
                
        <hr/>        
        
        <a name="data" id="data"></a>
        <h5>Data Access Object Pattern</h5>
        <p>Data Access Object Pattern or DAO pattern is used to separate low 
           level data accessing API or operations from high level business 
           services. Following are the participants in Data Access Object 
           Pattern.</p>

        <ul>    
          <li>Data Access Object Interface - This interface defines the standard
              operations to be performed on a model object(s).</li>
          <li>Data Access Object concrete class - This class implements above 
              interface. This class is responsible to get data from a data 
              source which can be database / xml or any other storage 
              mechanism.</li>
          <li>Model Object or Value Object - This object is simple POJO 
              containing get/set methods to store data retrieved using DAO 
              class.</li>
        </ul>
        
        <h5>Implementation</h5>
        <p>We are going to create a Student object acting as a Model or Value 
           Object. StudentDao is Data Access Object Interface.StudentDaoImpl is 
           concrete class implementing Data Access Object Interface. 
           DaoPatternDemo, our demo class, will use StudentDao to demonstrate 
           the use of Data Access Object pattern.</p>

        <h5>When to use</h5>        
        <ul>
          <li>To abstract and encapsulate all access to the data source. The DAO 
              manages the connection with the data source to obtain and store 
              data.</li>
        </ul>
        
        <img src="../assets/images/dataPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Value Object.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/dataaccessobject/Student.java"
           target="_blank"> 
          Student.java</a>
        
<pre>
<code>
public class Student {
   private String name;
   private int rollNo;

   Student(String name, int rollNo){
      this.name = name;
      this.rollNo = rollNo;
   }

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

   public int getRollNo() {
      return rollNo;
   }

   public void setRollNo(int rollNo) {
      this.rollNo = rollNo;
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create Data Access Object Interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/dataaccessobject/StudentDao.java"
           target="_blank"> 
          StudentDao.java</a>
        
<pre>
<code>
import java.util.List;

public interface StudentDao {
   public List<Student> getAllStudents();
   public Student getStudent(int rollNo);
   public void updateStudent(Student student);
   public void deleteStudent(Student student);
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create concrete class implementing above interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/dataaccessobject/StudentDaoImpl.java"
           target="_blank"> 
          StudentDaoImp1.java</a>
        
<pre>
<code>
import java.util.ArrayList;
import java.util.List;

public class StudentDaoImpl implements StudentDao {	
   //list is working as a database
   List<Student> students;

   public StudentDaoImpl(){
      students = new ArrayList<Student>();
      Student student1 = new Student("Robert",0);
      Student student2 = new Student("John",1);
      students.add(student1);
      students.add(student2);		
   }
   @Override
   public void deleteStudent(Student student) {
      students.remove(student.getRollNo());
      System.out.println("Student: Roll No " 
                   + student.getRollNo() + ", 
                     deleted from database");
   }

   //retrive list of students from the database
   @Override
   public List<Student> getAllStudents() {
      return students;
   }

   @Override
   public Student getStudent(int rollNo) {
      return students.get(rollNo);
   }

   @Override
   public void updateStudent(Student student) {
      students.get(student.getRollNo()).
               setName(student.getName());
      System.out.println("Student: Roll No " 
                        + student.getRollNo() + ", 
                          updated in the database");
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the StudentDao to demonstrate Data Access Object pattern usage.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/dataaccessobject/DaoPattern.java"
           target="_blank"> 
          DaoPattern.java</a>
        
<pre>
<code>
public class DaoPatternDemo {
   public static void main(String[] args) {
      StudentDao studentDao = new StudentDaoImpl();

      //print all students
      for (Student student : studentDao.getAllStudents()) {
         System.out.println("Student: [RollNo : " 
                           + student.getRollNo() + ", 
                             Name : " 
                           + student.getName() + " ]");
      }

      //update student
      Student student =studentDao.getAllStudents().get(0);
      student.setName("Michael");
      studentDao.updateStudent(student);

      //get the student
      studentDao.getStudent(0);
      System.out.println("Student: [RollNo : " 
                        + student.getRollNo() + ", 
                          Name : " 
                        + student.getName() + " ]");		
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Student: [RollNo : 0, Name : Robert ]
Student: [RollNo : 1, Name : John ]
Student: Roll No 0, updated in the database
Student: [RollNo : 0, Name : Michael ]        
</code>
</pre> 

        <hr/>
        
        <a name="front" id="front"></a>
        <h5>Front Controller Pattern</h5>        
        <p>The front controller design pattern is used to provide a centralized 
           request handling mechanism so that all requests will be handled by a 
           single handler. This handler can do the authentication/ 
           authorization/ logging or tracking of request and then pass the 
           requests to corresponding handlers. Following are the entities of 
           this type of design pattern.</p>

        <ul>    
          <li>Front Controller - Single handler for all kinds of requests coming
              to the application (either web based/ desktop based).</li>
          <li>Dispatcher - Front Controller may use a dispatcher object which 
              can dispatch the request to corresponding specific handler.</li>
          <li>View - Views are the object for which the requests are made.</li>
        </ul>
        
        <h5>Implementation</h5>       
        <p>We are going to create a FrontController and Dispatcher to act as 
           Front Controller and Dispatcher correspondingly. HomeView and 
           StudentView represent various views for which requests can come to 
           front controller.</p>
        
        <ul>
          <li>Use a controller as the initial point of contact for handling a 
           request. The controller manages the handling of the request, 
           including invoking security services such as authentication and 
           authorization, delegating business processing, managing the choice 
           of an appropriate view, handling errors, and managing the selection 
           of content creation strategies.</li>
        </ul>
                
        <p>FrontControllerPatternDemo, our demo class, will use FrontController 
           to demonstrate Front Controller Design Pattern.</p>

        <img src="../assets/images/frontControllerPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Views.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/frontcontroller/HomeView.java"
           target="_blank"> 
          HomeView.java</a>
        
<pre>
<code>
public class HomeView {
   public void show(){
      System.out.println("Displaying Home Page");
   }
}
</code>
</pre>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/frontcontroller/StudentView.java"
           target="_blank"> 
          StudentView.java</a>
        
<pre>
<code>
public class StudentView {
   public void show(){
      System.out.println("Displaying Student Page");
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create Dispatcher.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/frontcontroller/Dispatcher.java"
           target="_blank"> 
          Dispatcher.java</a>
        
<pre>
<code>
public class Dispatcher {
   private StudentView studentView;
   private HomeView homeView;
   
   public Dispatcher(){
      studentView = new StudentView();
      homeView = new HomeView();
   }

   public void dispatch(String request){
      if(request.equalsIgnoreCase("STUDENT")){
         studentView.show();
      }
      else{
         homeView.show();
      }	
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create FrontController</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/frontcontroller/FrontController.java"
           target="_blank"> 
          FrontController.java</a>
        
<pre>
<code>
public class FrontController {	
   private Dispatcher dispatcher;

   public FrontController(){
      dispatcher = new Dispatcher();
   }

   private boolean isAuthenticUser(){
      System.out.println("User is authenticated successfully.");
      return true;
   }

   private void trackRequest(String request){
      System.out.println("Page requested: " + request);
   }

   public void dispatchRequest(String request){
      //log each request
      trackRequest(request);
      
      //authenticate the user
      if(isAuthenticUser()){
         dispatcher.dispatch(request);
      }	
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Use the FrontController to demonstrate Front Controller Design Pattern.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/frontcontroller/FrontControllerPattern.java"
           target="_blank"> 
          FrontControllerPattern.java</a>
        
<pre>
<code>
public class FrontControllerPatternDemo {
   public static void main(String[] args) {   
      FrontController frontController = new FrontController();
      frontController.dispatchRequest("HOME");
      frontController.dispatchRequest("STUDENT");
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Verify the output.</p>

<pre>
<code>
Page requested: HOME
User is authenticated successfully.
Displaying Home Page
Page requested: STUDENT
User is authenticated successfully.
Displaying Student Page        
</code>
</pre>        

        <hr/>

        <a name="intercepting" id="intercepting"></a>
        <h5>Intercepting Filter Pattern</h5>        
        <p>The intercepting filter design pattern is used when we want to do 
           some pre-processing / post-processing with request or response of 
           the application. Filters are defined and applied on the request 
           before passing the request to actual target application. Filters 
           can do the authentication/ authorization/ logging or tracking of 
           request and then pass the requests to corresponding handlers. 
           Following are the entities of this type of design pattern.</p>

        <ul>
          <li>Filter - Filter which will performs certain task prior or after 
                       execution of request by request handler.</li>
          <li>Filter Chain - Filter Chain carries multiple filters and help to 
                             execute them in defined order on target.</li>
          <li>Target - Target object is the request handler</li>
          <li>Filter Manager - Filter Manager manages the filters and Filter 
                               Chain.</li>
          <li>Client - Client is the object who sends request to the Target 
                       object.</li>
        </ul>

        <h5>Implementation</h5>
        <p>We are going to create a FilterChain,FilterManager, Target, Client 
           as various objects representing our entities.AuthenticationFilter and
           DebugFilter represent concrete filters.</p>

        <p>InterceptingFilterDemo, our demo class, will use Client to 
           demonstrate Intercepting Filter Design Pattern.</p>

        <img src="../assets/images/InterceptingFilterPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Filter interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/Filter.java"
           target="_blank"> 
          Filter.java</a>
        
<pre>
<code>        
public interface Filter {
   public void execute(String request);
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete filters.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/AuthenticationFilter.java"
           target="_blank"> 
          AuthenticationFilter.java</a>
        
<pre>
<code>        
public class AuthenticationFilter implements Filter {
   public void execute(String request){
      System.out.println("Authenticating request: " + request);
   }
}
</code>
</pre>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/DebugFilter.java"
           target="_blank"> 
          DebugFilter.java</a>
        
<pre>
<code>        
public class DebugFilter implements Filter {
   public void execute(String request){
      System.out.println("request log: " + request);
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create Target</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/Target.java"
           target="_blank"> 
          Target.java</a>
        
<pre>
<code>        
public class Target {
   public void execute(String request){
      System.out.println("Executing request: " + request);
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create Filter Chain</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/FilterChain.java"
           target="_blank"> 
          FilterChain.java</a>
        
<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class FilterChain {
   private List < Filter > filters =
           new ArrayList < Filter >();
   private Target target;

   public void addFilter(Filter filter){
      filters.add(filter);
   }

   public void execute(String request){
      for (Filter filter : filters) {
         filter.execute(request);
      }
      target.execute(request);
   }

   public void setTarget(Target target){
      this.target = target;
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Create Filter Manager</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/FilterManager.java"
           target="_blank"> 
          FilterManager.java</a>
        
<pre>
<code>        
public class FilterManager {
   FilterChain filterChain;

   public FilterManager(Target target){
      filterChain = new FilterChain();
      filterChain.setTarget(target);
   }
   public void setFilter(Filter filter){
      filterChain.addFilter(filter);
   }

   public void filterRequest(String request){
      filterChain.execute(request);
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Create Client</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/Client.java"
           target="_blank"> 
          Client.java</a>
        
<pre>
<code>        
public class Client {
   FilterManager filterManager;

   public void setFilterManager(FilterManager filterManager){
      this.filterManager = filterManager;
   }

   public void sendRequest(String request){
      filterManager.filterRequest(request);
   }
}
</code>
</pre>

        <p><strong>Step 7</strong><br/>
        Use the Client to demonstrate Intercepting Filter Design Pattern.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/interceptingfilter/InterceptingFilter.java"
           target="_blank"> 
          InterceptingFilter.java</a>
        
<pre>
<code>
public class InterceptingFilter {
   public static void main(String[] args) {
      FilterManager filterManager = new FilterManager(new Target());
      filterManager.setFilter(new AuthenticationFilter());
      filterManager.setFilter(new DebugFilter());

      Client client = new Client();
      client.setFilterManager(filterManager);
      client.sendRequest("HOME");
   }
}
</code>
</pre>

        <p><strong>Step 8</strong><br/>
        Verify the output.</p>

<pre>
<code>
Authenticating request: HOME
request log: HOME
Executing request: HOME
</code>
</pre>        

        <hr/>

        <a name="service" id="service"></a>
        <h5>Service Locator Pattern</h5>
          
        <p>The service locator design pattern is used when we want to locate 
           various services using JNDI lookup. Considering high cost of looking 
           up JNDI for a service, Service Locator pattern makes use of caching 
           technique. For the first time a service is required, Service Locator 
           looks up in JNDI and caches the service object. Further lookup or 
           same service via Service Locator is done in its cache which improves 
           the performance of application to great extent. Following are the 
           entities of this type of design pattern.</p>

        <ul>
          <li>Service - Actual Service which will process the request. Reference
                        of such service is to be looked upon in JNDI 
                        server.</li>
          <li>Context / Initial Context - JNDI Context carries the reference to 
                                          service used for lookup purpose.</li>
          <li>Service Locator - Service Locator is a single point of contact to 
                                get services by JNDI lookup caching the 
                                services.</li>
          <li>Cache - Cache to store references of services to reuse them</li>
          <li>Client - Client is the object that invokes the services via 
                       ServiceLocator.</li>
        </ul>

        <h5>Implementation</h5>
        <p>We are going to create a ServiceLocator,InitialContext, Cache, 
            Service as various objects representing our entities.Service1 and 
            Service2 represent concrete services.</p>

        <p>ServiceLocatorPatternDemo, our demo class, is acting as a client 
           here and will use ServiceLocator to demonstrate Service Locator 
           Design Pattern.</p>

        <img src="../assets/images/ServiceLocatorPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Service interface.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/Service.java"
           target="_blank"> 
          Service.java</a>
        
<pre>
<code>        
public interface Service {
   public String getName();
   public void execute();
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create concrete services.</p>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/Service1.java"
           target="_blank"> 
          Service1.java</a>
        
<pre>
<code>        
public class Service1 implements Service {
   public void execute(){
      System.out.println("Executing Service1");
   }

   @Override
   public String getName() {
      return "Service1";
   }
}
</code>
</pre>
        
        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/Service2.java"
           target="_blank"> 
          Service2.java</a>
        
<pre>
<code>        
public class Service2 implements Service {
   public void execute(){
      System.out.println("Executing Service2");
   }

   @Override
   public String getName() {
      return "Service2";
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Create InitialContext for JNDI lookup</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/InitialContext.java"
           target="_blank"> 
          InitialContext.java</a>
        
<pre>
<code>        
public class InitialContext {
   public Object lookup(String jndiName){   
      if(jndiName.equalsIgnoreCase("SERVICE1")){
         System.out.println("Looking up and creating a new Service1 object");
         return new Service1();
      }
      else if (jndiName.equalsIgnoreCase("SERVICE2")){
         System.out.println("Looking up and creating a new Service2 object");
         return new Service2();
      }
      return null;		
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Create Cache</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/Cache.java"
           target="_blank"> 
          Cache.java</a>
        
<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class Cache {
   private List<Service> services;

   public Cache(){
      services = new ArrayList<Service>();
   }

   public Service getService(String serviceName){
      for (Service service : services) {
         if(service.getName().equalsIgnoreCase(serviceName)){
            System.out.println("Returning cached  " 
                              + serviceName + " object");
            return service;
         }
      }
      return null;
   }

   public void addService(Service newService){
      boolean exists = false;
      
      for (Service service : services) {
         if(service.getName().equalsIgnoreCase(newService.getName())){
            exists = true;
         }
      }
      if(!exists){
         services.add(newService);
      }
   }
}
</code>
</pre>

        <p><strong>Step 5</strong><br/>
        Create Service Locator</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/ServiceLocator.java"
           target="_blank"> 
          ServiceLocator.java</a>
        
<pre>
<code>        
public class ServiceLocator {
   private static Cache cache;

   static {
      cache = new Cache();		
   }

   public static Service getService(String jndiName){
      Service service = cache.getService(jndiName);
      
      if(service != null){
         return service;
      }

      InitialContext context = new InitialContext();
      Service service1 = (Service)context.lookup(jndiName);
      cache.addService(service1);
      return service1;
   }
}
</code>
</pre>

        <p><strong>Step 6</strong><br/>
        Use the ServiceLocator to demonstrate Service Locator Design 
        Pattern.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/servicelocator/ServiceLocatorPattern.java"
           target="_blank"> 
          ServiceLocatorPattern.java</a>
        
<pre>
<code>
public class ServiceLocatorPatternDemo {
   public static void main(String[] args) {
      Service service = ServiceLocator.getService("Service1");
      service.execute();
      service = ServiceLocator.getService("Service2");
      service.execute();
      service = ServiceLocator.getService("Service1");
      service.execute();
      service = ServiceLocator.getService("Service2");
      service.execute();		
   }
}
</code>
</pre>

        <p><strong>Step 7</strong><br/>
        Verify the output.</p>

<pre>
<code>
Looking up and creating a new Service1 object
Executing Service1
Looking up and creating a new Service2 object
Executing Service2
Returning cached  Service1 object
Executing Service1
Returning cached  Service2 object
Executing Service2
</code>
</pre>

        <hr/>
        <a name="transfer" id="transfer"></a>
        <h5>Transfer Object Pattern</h5>
        <p>The Transfer Object pattern is used when we want to pass data with 
           multiple attributes in one shot from client to server. Transfer 
           object is also known as Value Object. Transfer Object is a simple 
           POJO class having getter/setter methods and is serializable so that 
           it can be transferred over the network. It does not have any 
           behavior. Server Side business class normally fetches data from the 
           database and fills the POJO and send it to the client or pass it by 
           value. For client, transfer object is read-only. Client can create 
           its own transfer object and pass it to server to update values in 
           database in one shot. Following are the entities of this type of 
           design pattern.</p>

        <ul>
          <li>Business Object - Business Service fills the Transfer Object 
                                with data.</li>
          <li>Transfer Object - Simple POJO having methods to set/get attributes
                                only.</li>
          <li>Client - Client either requests or sends the Transfer Object to 
                       Business Object.</li>
        </ul>

        <h5>Implementation</h5>
        <p>We are going to create a StudentBO as Business Object,Student as 
            Transfer Object representing our entities.</p>

        <p>TransferObjectPatternDemo, our demo class, is acting as a client 
           here and will use StudentBO and Student to demonstrate Transfer 
           Object Design Pattern.</p>

        <img src="../assets/images/TransferObjectPattern.png" alt=""/>

        <p><strong>Step 1</strong><br/>
        Create Transfer Object.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/transferobject/StudentVO.java"
           target="_blank"> 
          StudentVO.java</a>
        
<pre>
<code>
public class StudentVO {
   private String name;
   private int rollNo;

   StudentVO(String name, int rollNo){
      this.name = name;
      this.rollNo = rollNo;
   }

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

   public int getRollNo() {
      return rollNo;
   }

   public void setRollNo(int rollNo) {
      this.rollNo = rollNo;
   }
}
</code>
</pre>

        <p><strong>Step 2</strong><br/>
        Create Business Object.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/transferobject/StudentBO.java"
           target="_blank"> 
          StudentBO.java</a>
        
<pre>
<code>        
import java.util.ArrayList;
import java.util.List;

public class StudentBO {	
   //list is working as a database
   List<StudentVO> students;

   public StudentBO(){
      students = new ArrayList<StudentVO>();
      StudentVO student1 = new StudentVO("Robert",0);
      StudentVO student2 = new StudentVO("John",1);
      students.add(student1);
      students.add(student2);		
   }
   public void deleteStudent(StudentVO student) {
      students.remove(student.getRollNo());
      System.out.println("Student: Roll No " 
                        + student.getRollNo() + ", 
                        deleted from database");
   }

   //retrive list of students from the database
   public List<StudentVO> getAllStudents() {
      return students;
   }

   public StudentVO getStudent(int rollNo) {
      return students.get(rollNo);
   }

   public void updateStudent(StudentVO student) {
    students.get(student.getRollNo())
        .setName(student.getName());
      System.out.println("Student: Roll No " 
                        + student.getRollNo() +", 
                        updated in the database");
   }
}
</code>
</pre>

        <p><strong>Step 3</strong><br/>
        Use the StudentBO to demonstrate Transfer Object Design Pattern.</p>

        See <span class="fa fa-file-code"></span>
        <a href="https://github.com/keeyanajones/Java-Design-Patterns/blob/master/src/j2ee/transferobject/TransferObjectPattern.java"
           target="_blank"> 
          TransferObjectPattern.java</a>
        
<pre>
<code>        
public class TransferObjectPatternDemo {
   public static void main(String[] args) {
      StudentBO studentBusinessObject = new StudentBO();

      //print all students
      for (StudentVO student : 
           studentBusinessObject.getAllStudents()) {
         System.out.println("Student: [RollNo : " 
                           + student.getRollNo() + ", 
                             Name : " + 
                             student.getName() + " ]");
      }

      //update student
      StudentVO student = 
         studentBusinessObject.getAllStudents().get(0);
      student.setName("Michael");
      studentBusinessObject.updateStudent(student);

      //get the student
      student = studentBusinessObject.getStudent(0);
      System.out.println("Student: [RollNo : " 
                        + student.getRollNo() + ", 
                        Name : " + 
                        student.getName() + " ]");
   }
}
</code>
</pre>

        <p><strong>Step 4</strong><br/>
        Verify the output.</p>

<pre>
<code>
Student: [RollNo : 0, Name : Robert ]
Student: [RollNo : 1, Name : John ]
Student: Roll No 0, updated in the database
Student: [RollNo : 0, Name : Michael ]
</code>
</pre>
        
<hr/>

        <h3><a name="take-five" class="anchor" href="#take-five">
          <span class="header-link"></span></a>
          Review</h3>
          
        <p>Alright, let's recap what I've just learned:</p>
    
        <ul>
            there are 33 design patterns which can be classified in four 
            categories: 
           
            <ul>               
              <li>Creational, Structural and Behavioral Patterns</li>
              <ul>
                <li>Creational Patterns</li>
                <ol>
                  <li>Factory</li>
                  <li>Abstract Factory</li>
                  <li>Singleton</li>
                  <li>Builder</li>
                  <li>Prototype</li>
                </ol>
                
                <li>Structural Patterns</li>
                <ol>
                  <li>Adapter, Wrapper, or Translator</li>
                  <li>Bridge</li>
                  <li>Filter or Criteria</li>
                  <li>Composite</li>
                  <li>Decorator</li>
                  <li>Facade</li>
                  <li>Flyweight</li>
                  <li>Proxy</li>
                </ol>
                
                <li>Behavioral Patterns</li>
                <ol>
                  <li>Chain of responsibility</li>
                  <li>Command</li>
                  <li>Interpreter</li>
                  <li>Iterator</li>
                  <li>Mediator</li>
                  <li>Memento</li>
                  <li>Observer/ Publish/ Subscribe</li>
                  <li>State </li>
                  <li>Null Object</li>
                  <li>Strategy</li>
                  <li>Template Method</li>
                  <li>Visitor</li>
                </ol>               
              </ul>
              
              <li>We also discuss another category of design pattern for 
                  Java Platform Enterprise Edition (J2EE)</li>
              <ol>
                <li>Modelviewcontroller (MVC)</li>
                <li>Business Delegate Pattern</li>
                <li>Composite Entity Pattern</li>
                <li>Data Access Object Pattern</li>
                <li>Front Controller Pattern</li>
                <li>Intercepting Filter Pattern</li>
                <li>Service Locator Pattern</li>
                <li>Transfer Object Pattern</li>                
              </ol>              
            </ul>            
        </ul>
        
    <p>You can read more at: 
        <a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank">          
            <small>
            https://en.wikipedia.org/wiki/Software_design_pattern
            </small>
        </a>
    </p>

      <!-- pagination -->
       <a role="button" class="btn btn-primary pull-left"  
               href="../uml/index.html">
            &larr; PREVIOUS: Unified Modeling Language (UML)</a>
          
      <a role="button" class="btn btn-primary pull-right" 
              href="../testing/index.html">
            NEXT: Testing &rarr;</a><br/><br/>
    </section>
        
    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" 
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" 
            crossorigin="anonymous"></script>         
    <script src="../assets/javascripts/scale.fix.js"></script>
  </body>
</html>

