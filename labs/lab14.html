<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Code Journal: Lab Typescript</title>   
    <!-- Latest compiled and minified CSS -->
    <!-- Font Awesome 5.7.0 -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.0/css/all.css" 
    integrity="sha384-lZN37f5QGtY3VHgisS14W3ExzMWZxybE1SJSEsQp9S+oqd12jhcu+A56Ebc1zFSJ" 
    crossorigin="anonymous">
    <!-- Bootstrap 4.3.1 -->    
    <link rel="stylesheet" 
          href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" 
          integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" 
          crossorigin="anonymous">   
    <!-- Highlight.js 9.13.1 -->     
    <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/androidstudio.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>    
    <script>hljs.initHighlightingOnLoad();</script>          

    <!-- Custom Style Pygment and Icons -->
    <link rel="stylesheet" href="../assets/stylesheets/styles.css">
    <link rel="stylesheet" href="../assets/stylesheets/pygment_trac.css">
    <link rel="icon" href="../assets/images/favicon.ico" type="image/gif">
    <link rel="shortcut icon" href="../assets/images/favicon.png">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>    

  <body>
    <div class="wrapper">               
    <!-- Header -->         
      <header>
          <img src="../assets/images/pb_Image.png" class="img-fluid" alt="me"/>
        <p class="view">A Code Journal for 
            <span class="fab fa-git-square" aria-hidden="true"></span>
                Hub Pages<br/>        
                
            <a href="https://github.com/keeyanajones/Journal" target="_blank">
            <span class="fab fa-github"></span> 
              View the Code Journal on GitHub</a></p>
                      
            <!-- Buttons -->                        
           <a class="btn btn-md btn-default" href="../appendix-projects/index.html#java" role="button">            
                <span class="fab fa-java fa-2x"></span> 
            </a>                   
            
           <a class="btn btn-md btn-default" href="../appendix-projects/index.html#python" role="button">
                <span class="fab fa-python fa-2x"></span> 
            </a>                        

           <a class="btn btn-md btn-default" href="../appendix-projects/index.html#node" role="button">
                <span class="fab fa-node fa-3x"></span> 
            </a>                
            
           <a class="btn btn-md btn-default" href="../appendix-projects/index.html#javascript" role="button">
                <span class="fab fa-js fa-2x"></span> 
            </a>                              

            <br/><br/>
            
            <a href="https://github.com/keeyanajones/">
            <small><span class="fab fa-github-alt"></span>                 
            Repositories and latest Contribution Activity</small></a>                 
              
        <br/>
        
        <!-- Download, Clone, or Fork -->
        <ul>    
          <li><a href="https://github.com/keeyanajones/Journal/archive/master.zip">
              <span class="fa fa-file-archive" aria-hidden="true"></span><br/>
                  Download <br/> ZIP</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-clone" aria-hidden="true"></span><br/>
                  Clone <br/> Desktop</a></li>                  
          <li><a href="https://github.com/keeyanajones/Journal">
              <span class="fa fa-code-branch" aria-hidden="true"></span><br/>
                  Fork On <br/> GitHub</a></li>
        </ul>                                 
      </header>
    <!-- ./header --> 
    </div>          
      
    <section>
        <h2><span class="fas fa-flask" aria-hidden="true"></span>
              <a name="lab14" class="anchor" href="#lab14">
              <span class="header-link"></span></a>
                Lab: TypeScript </h2>                  
     
        <p><sup><span class="fa fa-calendar"></span>
                Last updated on April 1st, 2020</sup></p>
                                                                     
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
                <span class="fa fa-bookmark"></span> 
                <a href="../index.html">Home</a></li>      
            <li class="breadcrumb-item">
                <span class="fa fa-bookmark"></span> 
                <a href="../learning-plan/index.html">         
                    Learning Plan</a></li>
            <li class="breadcrumb-item">
                <span class="fa fa-bookmark"></span> 
                <a href="../labs/index.html">        
                    Labs</a></li>    
            <li class="breadcrumb-item active" aria-current="typescript">
                <span class="fa fa-bookmark"></span>         
                TypeScript</li>
          </ol>
        </nav>                  
                
        <a name="lab14" id="lab14"></a>            
        <p>This section includes information about TypeScript labs.</p>

        <h4>EXERCISES</h4>

        <ul>
            <li>Exercise 0 : TypeScript </li>
            <li>Exercise 1 : Migrating from JavaScript</li>
        </ul>
        
        <p>TypeScript is an open-source programming language developed and 
           maintained by Microsoft. It is a strict syntactical superset of 
           JavaScript, and adds optional static typing to the language.

         It is designed for development of large applications and 
         transcompiles to JavaScript. As TypeScript is a superset of JavaScript, 
         existing JavaScript programs are also valid TypeScript programs. 
         TypeScript may be used to develop JavaScript applications for both 
         client-side and server-side execution (as with Node.js or Deno).</p>
         
         <p>There are multiple options available for transcompilation. Either the 
         default TypeScript Checker can be used, or the Babel compiler can be 
         invoked to convert TypeScript to JavaScript.
         
         It also supports definition files that can contain type information 
         of existing JavaScript libraries, much like C++ header files can 
         describe the structure of existing object files. This enables other 
         programs to use the values defined in the files as if they were 
         statically typed TypeScript entities.</p>
                  
         <p>There are third-party header 
         files for popular libraries such as jQuery, MongoDB, and D3.js. 
         TypeScript headers for the Node.js basic modules are also available, 
         allowing development of Node.js programs within TypeScript.</p>
                     
        <h4>REQUIRED RESOURCES</h4>
        <p>You will need a text editor, preferably with syntax highlighting. 
           A few options is VSCode, Visual Studio 2013 update 2 or later,
           Netbeans, Atom, Sublime Text, available on OS X, 
           Windows and Linux. You will need a web browser that includes a 
           debugger such as Chrome or Firefox or Edge. Apple disabled the Safari
           debugger by default, so read instructions to enable it first.</p>

        <h4>MATERIALS</h4>
        <p>List everything needed to complete your experiment. <br/>
            
            <span class="fas fa-external-link-alt"></span> 
            <a href="https://www.typescriptlang.org" target="_blank"> 
               https://www.typescriptlang.org</a><br/>
            
            <span class="fas fa-external-link-alt"></span> 
            <a href="https://www.typescriptlang.org/docs/index.html" target="_blank"> 
               https://www.typescriptlang.org/docs/index.html</a><br/>
			  
            <span class="fas fa-external-link-alt"></span> 
            <a href="https://www.typescriptlang.org/index.html#download-links" target="_blank"> 
               https://www.typescriptlang.org/index.html#download-links</a><br/>
            
            <span class="fas fa-external-link-alt"></span> 
            <a href="https://www.typescriptlang.org/docs/tutorial.html" target="_blank"> 
               https://www.typescriptlang.org/docs/tutorial.html</a><br/>            
         </p>			  

        <p>Please check the 
            <a href="material.md" target="_blank">
              materials.md</a> file.</p>  

        <p>Download the files required 
            <a href="lab1nodeRequired.zip" target="_blank">here</a> 
            and the complete solution for this lab 
            <a href="lab1nodeSolution.zip" target="_blank">here</a>.</p>


        <h4>VIDEOS</h4>

        <p>Helpful videos selected by me:</p>
        
        <span class="fas fa-external-link-alt"></span> 
        TypeScript
        
        <ul>            
          <li><a href="https://www.youtube.com/watch?v=xPEMup5SPTM" target="_blank"> 
            https://www.youtube.com/watch?v=xPEMup5SPTM</a></li>
        
          <li><a href="https://www.youtube.com/watch?v=BwuLxPH8IDs" target="_blank"> 
            https://www.youtube.com/watch?v=BwuLxPH8IDs</a></li>

          <li><a href="https://www.youtube.com/watch?v=82XE1X0Xblo" target="_blank"> 
            https://www.youtube.com/watch?v=82XE1X0Xblo</a></li>
        </ul>
        
        <h4>OVERVIEW</h4> 
        <p>The TypeScript compiler is itself written in TypeScript and compiled 
         to JavaScript. It is licensed under the Apache License 2.0.
         
         TypeScript is included as a first-class programming language in 
         Microsoft Visual Studio 2013 Update 2 and later, beside C# and other 
         Microsoft languages. An official extension allows Visual Studio 2012 
         to support TypeScript as well.
        </p>

        <h4>Exercise 0: TypeScript</h4>

        <p>There are two main ways to get the TypeScript tools:</p>

        <ul>
            <li>Via npm (the Node.js package manager)</li>
            <li>By installing TypeScript’s Visual Studio plugins</li>
         </ul>

         <p>Visual Studio 2017 and Visual Studio 2015 Update 3 include 
            TypeScript by default. If you didn’t install TypeScript with 
            Visual Studio, you can still download it.</p>


         <p>Try running Node interactively from the console built in to your 
                browser.</p>  
    
         <h5>Instructions</h5>              
         <p>For NPM users:</p>
         
<pre><code class="console">         
> npm install -g typescript
</code></pre>
         
         <p>In your editor, type the following JavaScript code in greeter.ts:</p>

<pre><code class="typescript">         
function greeter(person) {
  return "Hello, " + person;
}

let user = "Jane User";

document.body.textContent = greeter(user);
</code></pre>
                 
         <p>We used a .ts extension, but this code is just JavaScript. You could 
            have copy/pasted this straight out of an existing JavaScript app.         
            At the command line, run the TypeScript compiler:</p>

<pre><code>         
tsc greeter.ts
</code></pre>         

         <p>The result will be a file greeter.js which contains the same 
            JavaScript that you fed in. We’re up and running using TypeScript 
            in our JavaScript app!
         
            Now we can start taking advantage of some of the new tools TypeScript 
            offers. Add a : string type annotation to the ‘person’ function argument 
            as shown here:</p>

<pre><code class="typescript">         
function greeter(person: string) {
  return "Hello, " + person;
}

let user = "Jane User";

document.body.textContent = greeter(user);
</code></pre>
        
         <p>Type annotations in TypeScript are lightweight ways to record the 
            intended contract of the function or variable. In this case, we 
            intend the greeter function to be called with a single string 
            parameter. We can try changing the call greeter to pass an array 
            instead:

<pre><code>            
function greeter(person: string) {
  return "Hello, " + person;
}

let user = [0, 1, 2];

document.body.textContent = greeter(user);
</code></pre>

         <p>Re-compiling, you’ll now see an error:</p>
        
<pre><code>         
error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
</code></pre>

         <p>Similarly, try removing all the arguments to the greeter call. 
            TypeScript will let you know that you have called this function 
            with an unexpected number of parameters. In both cases, TypeScript 
            can offer static analysis based on both the structure of your code, 
            and the type annotations you provide.</p>
         
         <p>Notice that although there were errors, the greeter.js file is still 
            created. You can use TypeScript even if there are errors in your code. 
            But in this case, TypeScript is warning that your code will likely not 
            run as expected.</p>
         
         <p>Let’s develop our sample further. Here we use an interface that 
            describes objects that have a firstName and lastName field. In 
            TypeScript, two types are compatible if their internal structure is 
            compatible. This allows us to implement an interface just by having 
            the shape the interface requires, without an explicit implements 
            clause.</p>

<pre><code>            
interface Person {
  firstName: string;
  lastName: string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = { firstName: "Jane", lastName: "User" };

document.body.textContent = greeter(user);
</code></pre>

         
         <p>Finally, let’s extend the example one last time with classes. 
            TypeScript supports new features in JavaScript, like support 
            for class-based object-oriented programming.
         
            Here we’re going to create a Student class with a constructor 
            and a few public fields. Notice that classes and interfaces 
            play well together, letting the programmer decide on the right 
            level of abstraction.</p>
         
         <p>Also of note, the use of public on arguments to the constructor 
            is a shorthand that allows us to automatically create properties 
            with that name.</p>

<pre><code>            
class Student {
  fullName: string;
    constructor(public firstName: string, 
                public middleInitial: string, 
                public lastName: string) {
      this.fullName = firstName + " " + 
                      middleInitial + " " +
                      lastName;
    }
}

interface Person {
  firstName: string;
  lastName: string;
}

function greeter(person: Person) {
  return "Hello, " 
    + person.firstName + " " + person.lastName;
}

let user = new Student("Jane", "M.", "User");

document.body.textContent = greeter(user);
</code></pre>
         
         <p>Re-run tsc greeter.ts and you’ll see the generated JavaScript is 
            the same as the earlier code. Classes in TypeScript are just a 
            shorthand for the same prototype-based OO that is frequently used 
            in JavaScript.</p>
          
         <p>Now type the following in greeter.html:</p>

<pre><code>         
&lt;!DOCTYPE html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;TypeScript Greeter&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;script src="greeter.js"&gt;&lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>         

         <p>Open greeter.html in the browser to run your first simple TypeScript 
            web application!</p>
      
            <h4>Exercise 1: Migrating from JavaScript</h4>
            
            <p>TypeScript doesn’t exist in a vacuum. It was built with the JavaScript 
            ecosystem in mind, and a lot of JavaScript exists today. Converting a 
            JavaScript codebase over to TypeScript is, while somewhat tedious, 
            usually not challenging. In this tutorial, we’re going to look at how 
            you might start out. We assume you’ve read enough of the handbook to 
            write new TypeScript code.</p>
            
            <p>If you’re looking to convert a React project, we recommend looking at 
            the React Conversion Guide first.</p>
                        
            <p>If you’re writing in plain JavaScript, it’s likely that you’re running 
            your JavaScript directly, where your .js files are in a src, lib, or dist 
            directory, and then ran as desired.</p>
            
            <p>If that’s the case, the files that you’ve written are going to be used as
            inputs to TypeScript, and you’ll run the outputs it produces. During our 
            JS to TS migration, we’ll need to separate our input files to prevent 
            TypeScript from overwriting them. If your output files need to reside in a 
            specific directory, then that will be your output directory.</p>
            
            <p>You might also be running some intermediate steps on your JavaScript, such 
            as bundling or using another transpiler like Babel. In this case, you might 
            already have a folder structure like this set up.</p>
            
            <p>From this point on, we’re going to assume that your directory is set up 
            something like this:</p>

<pre><code>            
projectRoot
├── src
│   ├── file1.js
│   └── file2.js
├── built
└── tsconfig.json
</code></pre>            

            <p>If you have a tests folder outside of your src directory, you might have 
                one tsconfig.json in src, and one in tests as well.</p>

            <h5>Writing a Configuration File</h5> 
            
            <p>TypeScript uses a file called tsconfig.json for managing your project’s 
               options, such as which files you want to include, and what sorts of 
               checking you want to perform. Let’s create a bare-bones one for our 
               project:</p>

<pre><code>            
{
    "compilerOptions": {
        "outDir": "./built",
        "allowJs": true,
        "target": "es5"
    },
    "include": [
        "./src/**/*"
    ]
}
</code></pre>

            <p>Here we’re specifying a few things to TypeScript:</p>
            
            <ul>
              <li>Read in any files it understands in the src directory (with include).</li>
              <li>Accept JavaScript files as inputs (with allowJs).</li>
              <li>Emit all of the output files in built (with outDir).</li>
              <li>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using target).</li>
            </ul>

            <p>At this point, if you try running tsc at the root of your project, you 
                should see output files in the built directory. The layout of files in 
                built should look identical to the layout of src. You should now have 
                TypeScript working with your project.</p>
                     
            <h5>Early Benefits</h5>
            
            <p>Even at this point you can get some great benefits from TypeScript 
               understanding your project. If you open up an editor like VS Code or 
               Visual Studio, you’ll see that you can often get some tooling support 
               like completion. You can also catch certain bugs with options like:</p>
         
            <ul>   
                <li>noImplicitReturns which prevents you from forgetting to return 
                    at the end of a function.</li>
                <li>noFallthroughCasesInSwitch which is helpful if you never want 
                    to forget a break statement between cases in a switch block.</li>
            </ul>

            <p>TypeScript will also warn about unreachable code and labels, which you 
                can disable with allowUnreachableCode and allowUnusedLabels 
                respectively.</p>


            <h5>Integrating with Build Tools</h5>
            
            <p>You might have some more build steps in your pipeline. Perhaps you 
                concatenate something to each of your files. Each build tool is 
                different, but we’ll do our best to cover the gist of things.</p>

            <h5>Gulp</h5>
            
            <p>If you’re using Gulp in some fashion, we have a tutorial on using Gulp 
                with TypeScript, and integrating with common build tools like Browserify, 
                Babelify, and Uglify. You can read more there.</p>

            <h5>Webpack</h5>
            
            <p>Webpack integration is pretty simple. You can use 
                awesome-typescript-loader, a TypeScript loader, combined with 
                source-map-loader for easier debugging. Simply run</p>

<pre><code>                            
npm install awesome-typescript-loader source-map-loader
</code></pre>

            <p>and merge in options from the following into your webpack.config.js 
                file:</p>

<pre><code>            
module.exports = {
  entry: "./src/index.ts",
  output: {
    filename: "./dist/bundle.js",
  },
  // Enable sourcemaps for debugging webpack's output.
  devtool: "source-map",
  resolve: {
    // Add '.ts' and '.tsx' as resolvable extensions.
    extensions: ["", ".webpack.js", ".web.js", 
                 ".ts", ".tsx", ".js"]
    },
    module: {
      loaders: [
        // All files with a '.ts' or '.tsx' extension 
        // will be handled by 'awesome-typescript-loader'.
        { test: /\.tsx?$/, loader: "awesome-typescript-loader" }
      ],
      preLoaders: [
        // All output '.js' files will have any sourcemaps 
        // re-processed by 'source-map-loader'.
        { test: /\.js$/, loader: "source-map-loader" }
      ]
    },
  // Other options...
};
</code></pre>

            <p>It’s important to note that awesome-typescript-loader will need to run 
                before any other loader that deals with .js files.</p>
            
            <p>The same goes for ts-loader, another TypeScript loader for Webpack. You 
                can read more about the differences between the two here.</p>
            
            <p>You can see an example of using Webpack in our tutorial on React and 
                Webpack.</p>
           
           
            <h5>Moving to TypeScript Files</h5>
            
            <p>At this point, you’re probably ready to start using TypeScript files. 
                The first step is to rename one of your .js files to .ts. If your file 
                uses JSX, you’ll need to rename it to .tsx.</p>
            
            <p>Finished with that step? Great! You’ve successfully migrated a file from 
                JavaScript to TypeScript!</p>
            
            <p>Of course, that might not feel right. If you open that file in an editor with 
                TypeScript support (or if you run tsc --pretty), you might see red squiggles 
                on certain lines. You should think of these the same way you’d think of red 
                squiggles in an editor like Microsoft Word. TypeScript will still translate 
                your code, just like Word will still let you print your documents.</p>
            
            <p>If that sounds too lax for you, you can tighten that behavior up. If, for 
                instance, you don’t want TypeScript to compile to JavaScript in the face of 
                errors, you can use the noEmitOnError option. In that sense, TypeScript has a 
                dial on its strictness, and you can turn that knob up as high as you want.</p>
            
            <p>If you plan on using the stricter settings that are available, it’s best to 
                turn them on now (see Getting Stricter Checks below). For instance, if you 
                never want TypeScript to silently infer any for a type without you explicitly 
                saying so, you can use noImplicitAny before you start modifying your files. 
                While it might feel somewhat overwhelming, the long-term gains become apparent 
                much more quickly.</p>
           
           
            <h5>Weeding out Errors</h5>
            
            <p>Like we mentioned, it’s not unexpected to get error messages after conversion. 
               The important thing is to actually go one by one through these and decide how 
               to deal with the errors. Often these will be legitimate bugs, but sometimes 
               you’ll have to explain what you’re trying to do a little better to TypeScript.
            </p>
           
           
            <h5>Importing from Modules</h5>
            
            <p>You might start out getting a bunch of errors like Cannot find name 'require'., 
               and Cannot find name 'define'.. In these cases, it’s likely that you’re using 
               modules. While you can just convince TypeScript that these exist by writing out
            </p>   
            
<pre><code>            
// For Node/CommonJS
declare function require(path: string): any;
</code></pre>            
            
            <p>or</p>

<pre><code>            
// For RequireJS/AMD
declare function define(...args: any[]): any;
</code></pre>

            <p>it’s better to get rid of those calls and use TypeScript syntax 
                for imports.</p>
            
            <p>First, you’ll need to enable some module system by setting 
                TypeScript’s module flag. Valid options are commonjs, amd, 
                system, and umd.</p>
            
            <p>If you had the following Node/CommonJS code:</p>
            
<pre><code>
var foo = require("foo");

foo.doStuff();
</code></pre>

            <p>or the following RequireJS/AMD code:</p>

<pre><code>            
define(["foo"], function(foo) {
    foo.doStuff();
})
</code></pre>            

            <p>then you would write the following TypeScript code:</p>
            
<pre><code>
import foo = require("foo");

foo.doStuff();
</code></pre>            


            <h5>Getting Declaration Files</h5>
            
            <p>If you started converting over to TypeScript imports, you’ll probably 
               run into errors like Cannot find module 'foo'.. The issue here is that 
               you likely don’t have declaration files to describe your library. 
               Luckily this is pretty easy. If TypeScript complains about a package 
               like lodash, you can just write</p>

<pre><code>            
npm install -S @types/lodash
</code></pre>
            
            <p>If you’re using a module option other than commonjs, you’ll need to set 
                your moduleResolution option to node.
            
               After that, you’ll be able to import lodash with no issues, and get 
               accurate completions.</p>


            Exporting from Modules #
            
            <p>Typically, exporting from a module involves adding properties to a value 
               like exports or module.exports. TypeScript allows you to use top-level 
               export statements. For instance, if you exported a function like so:</p>

<pre><code>            
module.exports.feedPets = function(pets) {
    // ...
}
</code></pre>

            <p>you could write that out as the following:</p>

<pre><code>
export function feedPets(pets) {
    // ...
}
</code></pre>            

            <p>Sometimes you’ll entirely overwrite the exports object. This is a common 
                pattern people use to make their modules immediately callable like in 
                this snippet:</p>

<pre><code>                
var express = require("express");
var app = express();
</code></pre>

            <p>You might have previously written that like so:</p>
            
<pre><code>            
function foo() {
    // ...
}
module.exports = foo;
</code></pre>

            <p>In TypeScript, you can model this with the export = construct.</p>

<pre><code>            
function foo() {
    // ...
}
export = foo;
</code></pre>            


            <h5>Too many/too few arguments</h5> 
            
            <p>You’ll sometimes find yourself calling a function with too many/few arguments. 
              Typically, this is a bug, but in some cases, you might have declared a function 
              that uses the arguments object instead of writing out any parameters:</p>
            
<pre><code>              
function myCoolFunction() {
  if (arguments.length == 2 && !Array.isArray(arguments[1])) {
    var f = arguments[0];
    var arr = arguments[1];
    // ...
  }
  // ...
}

myCoolFunction(function(x) { console.log(x) }, [1, 2, 3, 4]);
myCoolFunction(function(x) { console.log(x) }, 1, 2, 3, 4);
</code></pre>

            <p>In this case, we need to use TypeScript to tell any of our callers about
               the ways myCoolFunction can be called using function overloads.</p>

<pre><code>               
function myCoolFunction(f: (x: number) => void, nums: number[]): void;
function myCoolFunction(f: (x: number) => void, ...nums: number[]): void;
function myCoolFunction() {
  if (arguments.length == 2 && !Array.isArray(arguments[1])) {
    var f = arguments[0];
    var arr = arguments[1];
    // ...
  }
  // ...
}
</code></pre>

            <p>We added two overload signatures to myCoolFunction. The first checks 
              states that myCoolFunction takes a function (which takes a number), and 
              then a list of numbers. The second one says that it will take a 
              function as well, and then uses a rest parameter (...nums) to state that 
              any number of arguments after that need to be numbers.</p>


            <h5>Sequentially Added Properties</h5>
            
            <p>Some people find it more aesthetically pleasing to create an object and 
              add properties immediately after like so:</p>

<pre><code>            
var options = {};
options.color = "red";
options.volume = 11;
</code></pre>
            
            <p>TypeScript will say that you can’t assign to color and volume because it 
              first figured out the type of options as {} which doesn’t have any properties. 
              If you instead moved the declarations into the object literal themselves, 
              you’d get no errors:</p>

<pre><code>                        
let options = {
    color: "red",
    volume: 11
};
</code></pre>

            <p>You could also define the type of options and add a type assertion on 
              the object literal.</p>

<pre><code>            
interface Options { color: string; volume: number }

let options = {} as Options;
options.color = "red";
options.volume = 11;
</code></pre>
            
            <p>Alternatively, you can just say options has the type any which is the easiest 
              thing to do, but which will benefit you the least.</p>

            <h5>any, Object, and {}</h5>
            
            <p>You might be tempted to use Object or {} to say that a value can have any 
              property on it because Object is, for most purposes, the most general type. 
              However any is actually the type you want to use in those situations, since 
              it’s the most flexible type.</p>
            
            <p>For instance, if you have something that’s typed as Object you won’t be able 
              to call methods like toLowerCase() on it. Being more general usually means you 
              can do less with a type, but any is special in that it is the most general type 
              while still allowing you to do anything with it. That means you can call it, 
              construct it, access properties on it, etc. Keep in mind though, whenever you 
              use any, you lose out on most of the error checking and editor support that 
              TypeScript gives you.</p>
            
            <p>If a decision ever comes down to Object and {}, you should prefer {}. While they 
              are mostly the same, technically {} is a more general type than Object in certain 
              esoteric cases.</p>

            <h5>Getting Stricter Checks</h5> 
            
            <p>TypeScript comes with certain checks to give you more safety and analysis of 
              your program. Once you’ve converted your codebase to TypeScript, you can start 
              enabling these checks for greater safety.</p>


            <h5>No Implicit any</h5>
            
            <p>There are certain cases where TypeScript can’t figure out what certain types 
              should be. To be as lenient as possible, it will decide to use the type any in 
              its place. While this is great for migration, using any means that you’re not 
              getting any type safety, and you won’t get the same tooling support you’d get 
              elsewhere. You can tell TypeScript to flag these locations down and give an 
              error with the noImplicitAny option.</p>


            <h5>Strict null & undefined Checks</h5>
            
            <p>By default, TypeScript assumes that null and undefined are in the domain of 
              every type. That means anything declared with the type number could be null 
              or undefined. Since null and undefined are such a frequent source of bugs in 
              JavaScript and TypeScript, TypeScript has the strictNullChecks option to spare 
              you the stress of worrying about these issues.</p>
            
            <p>When strictNullChecks is enabled, null and undefined get their own types 
              called null and undefined respectively. Whenever anything is possibly null, you 
              can use a union type with the original type. So for instance, if something could 
              be a number or null, you’d write the type out as number | null.</p>
            
            <p>If you ever have a value that TypeScript thinks is possibly null/undefined, but 
              you know better, you can use the postfix ! operator to tell it otherwise.</p>

<pre><code>            
declare var foo: string[] | null;

foo.length;  // error - 'foo' is possibly 'null'

foo!.length; // okay - 'foo!' just has type 'string[]'
</code></pre>

            <p>As a heads up, when using strictNullChecks, your dependencies may 
               need to be updated to use strictNullChecks as well.</p>
            
            
            <h5>No Implicit any for this</h5>
            
            <p>When you use the this keyword outside of classes, it has the type 
               any by default. For instance, imagine a Point class, and imagine a 
               function that we wish to add as a method:</p>
            
<pre><code>            
class Point {
  constructor(public x, public y) {}
  getDistance(p: Point) {
    let dx = p.x - this.x;
    let dy = p.y - this.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
}
// ...

// Reopen the interface.
interface Point {
  distanceFromOrigin(point: Point): number;
}
Point.prototype.distanceFromOrigin = function(point: Point) {
  return this.getDistance({ x: 0, y: 0});
}
</code></pre>

            <p>This has the same problems we mentioned above - we could easily 
                have misspelled getDistance and not gotten an error. For this 
                reason, TypeScript has the noImplicitThis option. When that 
                option is set, TypeScript will issue an error when this is used 
                without an explicit (or inferred) type. The fix is to use a 
                this-parameter to give an explicit type in the interface or 
                in the function itself:</p>

<pre><code>            
Point.prototype.distanceFromOrigin = function(this: Point, point: Point) {
  return this.getDistance({ x: 0, y: 0});
}
</code></pre>
            

        <!-- pagination -->
        <a role="button" class="btn btn-primary float-left" 
        href="../labs/index.html">
        &larr; PREVIOUS: Labs</a>

        <a role="button" class="btn btn-primary float-right" 
        href="../field-reports/index.html">
        NEXT: Field Reports &rarr;</a><br/><br/>              
        </section>      
        
    <!-- jQuery library -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" 
            integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" 
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" 
            integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" 
            crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" 
            integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" 
            crossorigin="anonymous"></script>       
        <script src="../assets/javascripts/scale.fix.js"></script>   
    </body>
</html>
